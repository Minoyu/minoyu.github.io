[{"title":"SemVer? 起版本号当然要讲些规矩","date":"2019-05-26T14:12:11.000Z","path":"2019/05/26/whySemver版本号/","text":"什么是SemVer？最近吴大佬的科普下， 简单了解了一些SemVer语义化版本号的规范， 准备在这里记录和总结一些自己的想法。 首先， 我们来看一下前端React框架最近发布的版本号的命名。 v16.9.0-alpha.0 v16.8.6 v16.8.5 v16.8.4 v16.8.3 v16.8.2 v16.8.1 v16.8.0 v16.8.0-alpha.1 v16.7.0 可以看出 React 发布的版本是非常的清晰和规范的, 这就归功于Semver(语义化的版本)规范的功劳, 从中咱们不难可以总结出一些规律。 软件的版本通常由三位组成， 形如： X. Y. Z， 依照Semver规范， 版本格式： 主版本号. 次版本号. 修订号， 版本号递增规则如下： 主版本号： 当你做了不兼容的 API 修改 次版本号： 当你做了向下兼容的功能性新增 修订号： 当你做了向下兼容的问题修正。 版本是严格递增的， 例如React此处是： 16.8.5 -&gt; 16.8.6-&gt; 16.9.0 在发布重要版本时， 可以发布alpha、 rc等先行版本 先行版本号及版本编译元数据可以加到“主版本号. 次版本号. 修订号”的后面， 作为延伸。 以上的三点基本可以概括Semver规范所要求的版本号格式了， 具体的一些细则可以参考 https://semver.org/lang/zh-CN/ 版本号而已为啥会有Semver？在我的理解中， SemVer就是一套规定了版本号应该如何去表示， 如何增加， 如何进行比较， 不同的版本号意味着什么的规范。 也许在我们以往的认识中， 版本号是一个很随意的存在， 而判断它需不需要进位的依据仅仅是”我觉得差不多可以了改个版本了“。 然而当我们的项目变得庞大起来时， 往往需要分包或者依赖于一些其他的软件包。 软件包是会不断更新和变化的， 这时就存在了不同软件包版本之间的依赖关系， 一旦管理不慎， 很容易出现有一些bug的情况， 例如A包需要依赖B包的一个新功能， 但当前的B包过久无法提供， 软件包之间无法完成相互的依赖。 如今的前端项目， 打开我们的 package.json 文件， 我们甚至能找到几十个甚至上百个依赖的包。 而这很可能只是冰山一角， 还有许许多多依赖的依赖包。 于是忽， 如何更好的管理和规范这些包的版本， 让其统一便于理解和使用成为了一个问题。 因此， Github 起草了一个具有指导意义的， 统一的版本号表示规则， 称为 Semantic Versioning(语义化版本表示)。 有啥好处举个栗子？讲了很多大道理，不如我们举个例子来看看语义化后的版本如何让依赖地狱成为过去2333～。 首先， 我们假设有位 ”消防员“ ， 他参与救火任务时需要依赖 ”梯子“ 去攀爬。 消防员 平时训练时要使用”梯子”第三代第一版时新增的功能( 消防员 依赖于 梯子 v3.1.0 ) 于是， 在日后的救火任务中 消防员 可以放心的去使用版本号大等于 v3.1.0 但小于 v4.0.0 的梯子(出现不可兼容更新， 主版本号递增， 无法保证原有的功能特性可以兼容) 同时， 当有&gt;= 3.1.1 ~&lt; 3.2.0 版本的 梯子 发布时， 消防员 可以毫无顾虑， 无需学习就可使用， 因为这些梯子只是原有基础上的一些小修整(修订号更新无新功能添加， 仅为bugfix) 哈哈哈， 上面这个例子应该可以很好理解了吧。 由此可以看出， SemVer大大的规范了软件包之间的版本发布， 你甚至不用去了解更新的具体内容， 就可以决定是否需要更新到特定版本的软件包。 在package.json中的运用( ^~*x )当执行 npm install package -S 或 yarn add 来安装三方包时， 包管理器会首先安装包的最新版本， 然后将包名及版本号写入到 package.json 文件中。 我们可以对依赖包的版本号做一些修改来限定依赖包的版本范围。 例如: 兼容模块新发布的修订补丁版本： ~16.2.0、 16.2.x、 16.2， 只有修订版本的更新会被匹配。 兼容模块新发布的小版本、 修订补丁版本： ^16.2.0、 16.x、 16， 小版本及修订版本的更新会被匹配。 兼容模块新发布的大版本、 小版本、 修订补丁版本： *、 x， 所有的版本都会被比配。","tags":[{"name":"开发杂记","slug":"开发杂记","permalink":"https://minoyu.github.io/tags/开发杂记/"}]},{"title":"Hello World! My first hexo post! (hexo的常用命令及优化)","date":"2018-10-18T09:02:06.000Z","path":"2018/10/18/hello-world/","text":"关于这里哈哈哈，第一次尝试用Hexo来搭建一个博客，放在github page上，尝试了一下。以后这里主要用来记录我的学习笔记和一些探索总结吧。 话说觉得Hexo真的好神奇，脱离了数据库，用一个个md文档充当文章的内容，在本地写好md文档后编译成Html,再推上服务器。实现了纯静态的访问，蛮有意思的XD 那就这样吧，接下来开始我的记录咯。1$ hexo new \"My First Note！\" 个人博客: 我们的小确幸 hexo的常用命令12345678# 新建文章$ hexo new [layout] &lt;title&gt;# 生成静态文件$ hexo g# 部署网站$ hexo d# 清除缓存文件 (db.json) 和已生成的静态文件 (public)。$ hexo clean hexo的优化虽然hexo已经很优秀了，但考虑到毕竟是放在github page上的，还是稍微做一些优化。 静态资源优化主要是压缩html,css,js等等静态资源，可以适当减少请求的数据量，主要用到gulp来实现。 安装gulp 1234# 全局安装gulp工具 以yarn工具为例$ yarn global add gulp-cli# 给项目安装各种gulp插件 分别负责压缩html 图片 css js$ yarn add gulp gulp-htmlclean gulp-htmlmin gulp-imagemin gulp-minify-css gulp-uglify 配置文件 在根目录下添加gulpfile.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657var gulp = require('gulp');var minifycss = require('gulp-minify-css');var uglify = require('gulp-uglify');var htmlmin = require('gulp-htmlmin');var htmlclean = require('gulp-htmlclean');var imagemin = require('gulp-imagemin');// 压缩htmlgulp.task('minify-html', function() &#123; return gulp.src('./public/**/*.html') .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest('./public'))&#125;);// 压缩cssgulp.task('minify-css', function() &#123; return gulp.src('./public/**/*.css') .pipe(minifycss(&#123; compatibility: 'ie8' &#125;)) .pipe(gulp.dest('./public'));&#125;);// 压缩jsgulp.task('minify-js', function() &#123; return gulp.src('./public/js/**/*.js') .pipe(uglify()) .pipe(gulp.dest('./public'));&#125;);// 压缩图片gulp.task('minify-images', function() &#123; return gulp.src('./public/img/**/*.*') .pipe(imagemin( [imagemin.gifsicle(&#123;'optimizationLevel': 3&#125;), imagemin.jpegtran(&#123;'progressive': true&#125;), imagemin.optipng(&#123;'optimizationLevel': 7&#125;), imagemin.svgo()], &#123;'verbose': true&#125;)) .pipe(gulp.dest('./public/img'))&#125;);//4.0以前的写法 //gulp.task('default', [ // 'minify-html', 'minify-css', 'minify-js'，'minify-images'//]);// 默认任务 gulp4以上写法 gulp.parallel 任务同时进行gulp.task('default', gulp.parallel( 'minify-html', 'minify-css', 'minify-js', 'minify-images')); 在hexo g生成文件后运行gulp123$ hexo g$ gulp$ hexo d 生成sitemap文件生成sitemap文件然后提交给搜索引擎，对于SEO很有帮助，hexo有相关的sitemap插件。 安装这俩插件后，以后每次hexo g都会生成sitemap.xml和baidusitemap.xml文件并自动帮你放到public目录。 1$ yarn add hexo-generator-sitemap hexo-generator-baidu-sitemap","tags":[{"name":"杂类","slug":"杂类","permalink":"https://minoyu.github.io/tags/杂类/"},{"name":"Hello world","slug":"Hello-world","permalink":"https://minoyu.github.io/tags/Hello-world/"}]}]