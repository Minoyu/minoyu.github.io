[{"title":"SemVer? 起版本号当然要讲些规矩","date":"2019-05-26T14:12:11.000Z","path":"2019/05/26/whySemver版本号/","text":"什么是SemVer？最近吴大佬的科普下， 简单了解了一些SemVer语义化版本号的规范， 准备在这里记录和总结一些自己的想法。 首先， 我们来看一下前端React框架最近发布的版本号的命名。 v16.9.0-alpha.0 v16.8.6 v16.8.5 v16.8.4 v16.8.3 v16.8.2 v16.8.1 v16.8.0 v16.8.0-alpha.1 v16.7.0 可以看出 React 发布的版本是非常的清晰和规范的, 这就归功于Semver(语义化的版本)规范的功劳, 从中咱们不难可以总结出一些规律。 软件的版本通常由三位组成， 形如： X. Y. Z， 依照Semver规范， 版本格式： 主版本号. 次版本号. 修订号， 版本号递增规则如下： 主版本号： 当你做了不兼容的 API 修改 次版本号： 当你做了向下兼容的功能性新增 修订号： 当你做了向下兼容的问题修正。 版本是严格递增的， 例如React此处是： 16.8.5 -&gt; 16.8.6-&gt; 16.9.0 在发布重要版本时， 可以发布alpha、 rc等先行版本 先行版本号及版本编译元数据可以加到“主版本号. 次版本号. 修订号”的后面， 作为延伸。 以上的三点基本可以概括Semver规范所要求的版本号格式了， 具体的一些细则可以参考 https://semver.org/lang/zh-CN/ 不就是个版本号， 为啥会有Semver？在我的理解中， SemVer就是一套规定了版本号应该如何去表示， 如何增加， 如何进行比较， 不同的版本号意味着什么的规范。 也许在我们以往的认识中， 版本号是一个很随意的存在， 而判断它需不需要进位的依据仅仅是”我觉得差不多可以了改个版本了“。 然而当我们的项目变得庞大起来时， 往往需要分包或者依赖于一些其他的软件包。 软件包是会不断更新和变化的， 这时就存在了不同软件包版本之间的依赖关系， 一旦管理不慎， 很容易出现有一些bug的情况， 例如A包需要依赖B包的一个新功能， 但当前的B包过久无法提供， 软件包之间无法完成相互的依赖。 如今的前端项目， 打开我们的 package.json 文件， 我们甚至能找到几十个甚至上百个依赖的包。 而这很可能只是冰山一角， 还有许许多多依赖的依赖包。 于是忽， 如何更好的管理和规范这些包的版本， 让其统一便于理解和使用成为了一个问题。 因此， Github 起草了一个具有指导意义的， 统一的版本号表示规则， 称为 Semantic Versioning(语义化版本表示)。 有啥好处啊举个栗子？不如我们举个例子来看看语义化后的版本如何让依赖地狱成为过2333～。 首先， 我们假设有位 ”消防员“ ， 他参与救火任务时需要依赖 ”梯子“ 去攀爬。 消防员 平时训练时要使用”梯子”第三代第一版时新增的功能( 消防员 依赖于 梯子 v3.1.0 ) 于是， 在日后的救火任务中 消防员 可以放心的去使用版本号大等于 v3.1.0 但小于 v4.0.0 的梯子(出现不可兼容更新， 主版本号递增， 无法保证原有的功能特性可以兼容) 同时， 当有&gt;= 3.1.1 ~&lt; 3.2.0 版本的 梯子 发布时， 消防员 可以毫无顾虑， 无需学习就可使用， 因为这些梯子只是原有基础上的一些小修整(修订号更新无新功能添加， 仅为bugfix) 哈哈哈， 上面这个例子应该可以很好理解了吧。 由此可以看出， SemVer大大的规范了软件包之间的版本发布， 你甚至不用去了解更新的具体内容， 就可以决定是否需要更新到特定版本的软件包。 在package.json中的运用( ^~*x )当执行 npm install package -S 或 yarn add 来安装三方包时， 包管理器会首先安装包的最新版本， 然后将包名及版本号写入到 package.json 文件中。 我们可以对依赖包的版本号做一些修改来限定依赖包的版本范围。 例如: 兼容模块新发布的修订补丁版本： ~16.2.0、 16.2.x、 16.2， 只有修订版本的更新会被匹配。 兼容模块新发布的小版本、 修订补丁版本： ^16.2.0、 16.x、 16， 小版本及修订版本的更新会被匹配。 兼容模块新发布的大版本、 小版本、 修订补丁版本： *、 x， 所有的版本都会被比配。","tags":[{"name":"开发杂记","slug":"开发杂记","permalink":"https://minoyu.github.io/tags/开发杂记/"}]},{"title":"重学JS简略笔记04(标准库)","date":"2019-01-25T10:10:51.000Z","path":"2019/01/25/我的JavaScript简略笔记04/","text":"标准库Object对象概述JavaScript 的所有其他对象都继承自Object对象，即那些对象都是Object的实例。Object对象的原生方法分成两类：Object本身的方法与Object的实例方法。 Object对象本身的方法所谓“本身的方法”就是直接定义在Object对象的方法。1Object.print = function (o) &#123; console.log(o) &#125;; Object的实例方法所谓实例方法就是定义在Object原型对象Object.prototype上的方法。它可以被Object实例直接使用。123456Object.prototype.print = function () &#123; console.log(this);&#125;;var obj = new Object();obj.print() // Object Object()Object本身是一个函数，可以当作工具方法使用，将任意值转为对象。这个方法常用于保证某个值一定是对象。 PS. instanceof 运算符用来验证，一个对象是否为指定的构造函数的实例。 如果参数是原始类型的值，Object方法将其转为对应的包装对象的实例（参见《原始类型的包装对象》一章）。 1234567891011var obj = Object(1);obj instanceof Object // trueobj instanceof Number // truevar obj = Object('foo');obj instanceof Object // trueobj instanceof String // truevar obj = Object(true);obj instanceof Object // trueobj instanceof Boolean // true 如果Object方法的参数是一个对象，它总是返回该对象，即不用转换。 Object 构造函数Object不仅可以当作工具函数使用，还可以当作构造函数使用，即前面可以使用new命令。 Object构造函数的首要用途，是直接通过它来生成新对象。 注意，通过var obj = new Object()的写法生成新对象，与字面量的写法var obj = {}是等价的。或者说，后者只是前者的一种简便写法。Object构造函数的用法与工具方法很相似，几乎一模一样。使用时，可以接受一个参数，如果该参数是一个对象，则直接返回这个对象；如果是一个原始类型的值，则返回该值对应的包装对象（详见《包装对象》一章）。 Object 的静态方法所谓“静态方法”，是指部署在Object对象自身的方法。 Object.keys()，Object.getOwnPropertyNames()Object.keys方法和Object.getOwnPropertyNames方法都用来遍历对象的属性。 对于一般的对象来说，Object.keys()和Object.getOwnPropertyNames()返回的结果是一样的。只有涉及不可枚举属性时，才会有不一样的结果。Object.keys方法只返回可枚举的属性（详见《对象属性的描述对象》一章），Object.getOwnPropertyNames方法还返回不可枚举的属性名。1234var a = ['Hello', 'World'];Object.keys(a) // [\"0\", \"1\"]Object.getOwnPropertyNames(a) // [\"0\", \"1\", \"length\"] 上面代码中，数组的length属性是不可枚举的属性，所以只出现在Object.getOwnPropertyNames方法的返回结果中。 其他方法除了上面提到的两个方法，Object还有不少其他静态方法，将在后文逐一详细介绍。 对象属性模型的相关方法 Object.getOwnPropertyDescriptor()：获取某个属性的描述对象。 Object.defineProperty()：通过描述对象，定义某个属性。 Object.defineProperties()：通过描述对象，定义多个属性。 控制对象状态的方法 Object.preventExtensions()：防止对象扩展。 Object.isExtensible()：判断对象是否可扩展。 Object.seal()：禁止对象配置。 Object.isSealed()：判断一个对象是否可配置。 Object.freeze()：冻结一个对象。 Object.isFrozen()：判断一个对象是否被冻结。 原型链相关方法 Object.create()：该方法可以指定原型对象和属性，返回一个新的对象。 Object.getPrototypeOf()：获取对象的Prototype对象。Object 的实例方法除了静态方法，还有不少方法定义在Object.prototype对象。它们称为实例方法，所有Object的实例对象都继承了这些方法。 Object实例对象的方法，主要有以下六个。 Object.prototype.valueOf()：返回当前对象对应的值。 Object.prototype.toString()：返回当前对象对应的字符串形式。 Object.prototype.toLocaleString()：返回当前对象对应的本地字符串形式。 Object.prototype.hasOwnProperty()：判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性。 Object.prototype.isPrototypeOf()：判断当前对象是否为另一个对象的原型。 Object.prototype.propertyIsEnumerable()：判断某个属性是否可枚举。 Object.prototype.valueOf()valueOf方法的作用是返回一个对象的“值”，默认情况下返回对象本身。 valueOf方法的主要用途是，JavaScript 自动类型转换时会默认调用这个方法。123456789var obj = new Object();1 + obj // \"1[object Object]\"var obj = new Object();obj.valueOf = function () &#123; return 2;&#125;;1 + obj // 3 上面代码将对象obj与数字1相加，这时 JavaScript 就会默认调用valueOf()方法，求出obj的值再与1相加。所以，如果自定义valueOf方法，就可以得到想要的结果。 Object.prototype.toString()toString方法的作用是返回一个对象的字符串形式，默认情况下返回类型字符串。对于一个对象调用toString方法，会返回字符串[object Object]，该字符串说明对象的类型。 字符串[object Object]本身没有太大的用处，但是通过自定义toString方法，可以让对象在自动类型转换时，得到想要的字符串形式。 1234567var obj = new Object();obj.toString = function () &#123; return 'hello';&#125;;obj + ' ' + 'world' // \"hello world\" 数组、字符串、函数、Date 对象都分别部署了自定义的toString方法，覆盖了Object.prototype.toString方法。 toString() 的应用：判断数据类型由于实例对象可能会自定义toString方法，覆盖掉Object.prototype.toString方法，所以为了得到类型字符串，最好直接使用Object.prototype.toString方法。通过函数的call方法，可以在任意值上调用这个方法，帮助我们判断这个值的类型。 123456789Object.prototype.toString.call(value)Object.prototype.toString.call(2) // \"[object Number]\"Object.prototype.toString.call('') // \"[object String]\"Object.prototype.toString.call(true) // \"[object Boolean]\"Object.prototype.toString.call(undefined) // \"[object Undefined]\"Object.prototype.toString.call(null) // \"[object Null]\"Object.prototype.toString.call(Math) // \"[object Math]\"Object.prototype.toString.call(&#123;&#125;) // \"[object Object]\"Object.prototype.toString.call([]) // \"[object Array]\"","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://minoyu.github.io/tags/学习笔记/"},{"name":"《JavaScript 标准参考教程-阮一峰》","slug":"《JavaScript-标准参考教程-阮一峰》","permalink":"https://minoyu.github.io/tags/《JavaScript-标准参考教程-阮一峰》/"}]},{"title":"重学JS简略笔记03(语法专题)","date":"2019-01-24T13:07:27.000Z","path":"2019/01/24/我的JavaScript简略学习笔记03/","text":"语法专题数据类型的转换JavaScript 是一种动态类型语言，变量没有类型限制，可以随时赋予任意值。 虽然变量的数据类型是不确定的，但是各种运算符对数据类型是有要求的。如果运算符发现，运算子的类型与预期不符，就会自动转换类型。 强制转换强制转换主要指使用Number()、String()和Boolean()三个函数，手动将各种类型的值，分别转换成数字、字符串或者布尔值。 Number()对原始类型值 字符串：如果不可以被解析为数值，返回 NaN 空字符串转为0 布尔值：true 转成 1，false 转成 0 undefined：转成 NaN null：转成0 Number函数将字符串转为数值，要比parseInt函数严格很多。基本上，只要有一个字符无法转成数值，整个字符串就会被转为NaN。12parseInt('42 cats') // 42Number('42 cats') // NaN 另外，parseInt和Number函数都会自动过滤一个字符串前导和后缀的空格。12parseInt('\\t\\v\\r12.34\\n') // 12Number('\\t\\v\\r12.34\\n') // 12.34 对对象第一步，调用对象自身的valueOf方法。如果返回原始类型的值，则直接对该值使用Number函数，不再进行后续步骤。 第二步，如果valueOf方法返回的还是对象，则改为调用对象自身的toString方法。如果toString方法返回原始类型的值，则对该值使用Number函数，不再进行后续步骤。 第三步，如果toString方法返回的是对象，就报错。 默认情况下，对象的valueOf方法返回对象本身，所以一般总是会调用toString方法 String()String函数可以将任意类型的值转化成字符串，转换规则如下。 原始类型值 数值：转为相应的字符串。 字符串：转换后还是原来的值。 布尔值：true转为字符串”true”，false转为字符串”false”。 undefined：转为字符串”undefined”。 null：转为字符串”null”。对象String方法的参数如果是对象，返回一个类型字符串；如果是数组，返回该数组的字符串形式。 String方法背后的转换规则，与Number方法基本相同，只是互换了valueOf方法和toString方法的执行顺序。 先调用对象自身的toString方法。如果返回原始类型的值，则对该值使用String函数，不再进行以下步骤。 如果toString方法返回的是对象，再调用原对象的valueOf方法。如果valueOf方法返回原始类型的值，则对该值使用String函数，不再进行以下步骤。 如果valueOf方法返回的是对象，就报错。 Boolean()它的转换规则相对简单：除了以下五个值的转换结果为false，其他的值全部为true。 undefined null -0或+0 NaN ‘’（空字符串） 注意，所有对象（包括空对象）的转换结果都是true，甚至连false对应的布尔对象new Boolean(false)也是true（详见《原始类型值的包装对象》一章）。 错误处理机制JavaScript 解析或运行时，一旦发生错误，引擎就会抛出一个错误对象。JavaScript 原生提供Error构造函数，所有抛出的错误都是这个构造函数的实例。 JavaScript 语言标准只提到，Error实例对象必须有message属性，表示出错时的提示信息，没有提到其他属性。大多数 JavaScript 引擎，对Error实例还提供name和stack属性，分别表示错误的名称和错误的堆栈，但它们是非标准的，不是每种实现都有。 message：错误提示信息 name：错误名称（非标准属性） stack：错误的堆栈（非标准属性）原生错误类型Error实例对象是最一般的错误类型，在它的基础上，JavaScript 还定义了其他6种错误对象。也就是说，存在Error的6个派生对象。SyntaxError 对象SyntaxError对象是解析代码时发生的语法错误。ReferenceError 对象 ReferenceError对象是引用一个不存在的变量时发生的错误。 另一种触发场景是，将一个值分配给无法分配的对象，比如对函数的运行结果或者this赋值。RangeError 对象RangeError对象是一个值超出有效范围时发生的错误。主要有几种情况，一是数组长度为负数，二是Number对象的方法参数超出范围，以及函数堆栈超过最大值。TypeError 对象TypeError对象是变量或参数不是预期类型时发生的错误。比如，对字符串、布尔值、数值等原始类型的值使用new命令，就会抛出这种错误，因为new命令的参数应该是一个构造函数。 第二种情况，调用对象不存在的方法，也会抛出TypeError错误，因为obj.unknownMethod的值是undefined，而不是一个函数。 URIError 对象URIError对象是 URI 相关函数的参数不正确时抛出的错误，主要涉及encodeURI()、decodeURI()、encodeURIComponent()、decodeURIComponent()、escape()和unescape()这六个函数。 EvalError 对象eval函数没有被正确执行时，会抛出EvalError错误。该错误类型已经不再使用了，只是为了保证与以前代码兼容，才继续保留。 自定义错误除了 JavaScript 原生提供的七种错误对象，还可以定义自己的错误对象。1234567function UserError(message) &#123; this.message = message || '默认信息'; this.name = 'UserError';&#125;UserError.prototype = new Error();UserError.prototype.constructor = UserError; 上面代码自定义一个错误对象UserError，让它继承Error对象。然后，就可以生成这种自定义类型的错误了。1new UserError('这是自定义的错误！'); throw 语句throw语句的作用是手动中断程序执行，抛出一个错误。 实际上，throw可以抛出任何类型的值。也就是说，它的参数可以是任何值。 对于 JavaScript 引擎来说，遇到throw语句，程序就中止了。引擎会接收到throw抛出的信息，可能是一个错误实例，也可能是其他类型的值。 try…catch 结构123456789try &#123; throw new Error('出错了!');&#125; catch (e) &#123; console.log(e.name + \": \" + e.message); console.log(e.stack);&#125;// Error: 出错了!// at &lt;anonymous&gt;:3:9// ... try…catch结构允许在最后添加一个finally代码块，表示不管是否出现错误，都必需在最后运行的语句。","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://minoyu.github.io/tags/学习笔记/"},{"name":"《JavaScript 标准参考教程-阮一峰》","slug":"《JavaScript-标准参考教程-阮一峰》","permalink":"https://minoyu.github.io/tags/《JavaScript-标准参考教程-阮一峰》/"}]},{"title":"重学JS简略笔记02(运算符)","date":"2019-01-23T13:50:27.000Z","path":"2019/01/23/我的JavaScript简略学习笔记02/","text":"运算符算数运算符 JavaScript 共提供10个算术运算符，用来完成基本的算术运算。 加法运算符：x + y 减法运算符： x - y 乘法运算符： x * y 除法运算符：x / y 指数运算符：x ** y //x的y次方 余数运算符：x % y 自增运算符：++x 或者 x++ 自减运算符：--x 或者 x-- 数值运算符：+x 负数值运算符：-x 减法、乘法、除法运算法比较单纯，就是执行相应的数学运算 下面介绍其他几个算术运算符，重点是加法运算符。 加法运算符JavaScript 允许非数值的相加。 布尔值都会自动转成数值，然后再相加。 两个字符串相加，这时加法运算符会变成连接运算符，返回一个新的字符串，将两个原字符串连接在一起。 一个运算子是字符串，另一个运算子是非字符串，这时非字符串会转成字符串，再连接在一起。对象的相加如果运算子是对象，必须先转成原始类型的值，然后再相加。首先，自动调用对象的valueOf方法,一般来说，对象的valueOf方法总是返回对象自身。这时再自动调用对象的toString方法，将其转为字符串。12345var obj = &#123; p: 1 &#125;;obj + 2 // \"[object Object]2\"var obj = &#123; p: 1 &#125;;obj.valueOf().toString() // \"[object Object]\" 知道了这个规则以后，就可以自己定义valueOf方法或toString方法，得到想要的结果。1234567var obj = &#123; valueOf: function () &#123; return 1; &#125;&#125;;obj + 2 // 3 余数运算符需要注意的是，运算结果的正负号由第一个运算子的正负号决定。12-1 % 2 // -11 % -2 // 1 比较运算符JavaScript 一共提供了8个比较运算符。 &gt; 大于运算符 &lt; 小于运算符 &lt;= 小于或等于运算符 &gt;= 大于或等于运算符 == 相等运算符 === 严格相等运算符 != 不相等运算符 !== 严格不相等运算符 非相等运算符 在进行字符串比较时，字符串按照字典顺序进行比较。JavaScript 引擎内部首先比较首字符的 Unicode 码点。如果相等，再比较第二个字符的 Unicode 码点，以此类推。 非字符串的比较时，如果两个运算子都是原始类型的值，则是先转成数值再比较。这里需要注意与NaN的比较。任何值（包括NaN本身）与NaN比较，返回的都是false。 如果运算子是对象，会转为原始类型的值，再进行比较。先调用valueOf方法，如果返回的还是对象，再接着调用toString方法123456789101112131415161718192021var x = [2];x &gt; '11' // true// 等同于 [2].valueOf().toString() &gt; '11'// 即 '2' &gt; '11'x.valueOf = function () &#123; return '1' &#125;;x &gt; '11' // false// 等同于 [2].valueOf() &gt; '11'// 即 '1' &gt; '11'[2] &gt; [1] // true// 等同于 [2].valueOf().toString() &gt; [1].valueOf().toString()// 即 '2' &gt; '1'[2] &gt; [11] // true// 等同于 [2].valueOf().toString() &gt; [11].valueOf().toString()// 即 '2' &gt; '11'&#123; x: 2 &#125; &gt;= &#123; x: 1 &#125; // true// 等同于 &#123; x: 2 &#125;.valueOf().toString() &gt;= &#123; x: 1 &#125;.valueOf().toString()// 即 '[object Object]' &gt;= '[object Object]' 严格相等运算符JavaScript 提供两种相等运算符：==和===。 简单说，它们的区别是相等运算符（==）比较两个值是否相等，严格相等运算符（===）比较它们是否为“同一个值”。如果两个值不是同一类型，严格相等运算符（===）直接返回false，而相等运算符（==）会将它们转换成同一个类型，再用严格相等运算符进行比较。 如果两个值的类型不同，直接返回false。 同一类型的原始类型的值（数值、字符串、布尔值）比较时，值相同就返回true，值不同就返回false。需要注意的是，NaN与任何值都不相等（包括自身）。另外，正0等于负0。 两个复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个地址。 undefined和null与自身严格相等。 相等运算符 相等运算符用来比较相同类型的数据时，与严格相等运算符完全一样。 原始类型的值会转换成数值再进行比较。 对象（这里指广义的对象，包括数组和函数）与原始类型的值比较时，对象转换成原始类型的值，再进行比较。 undefined和null与其他类型的值比较时，结果都为false，它们互相比较时结果为true。 相等运算符隐藏的类型转换，会带来一些违反直觉的结果。12345678910111213140 == '' // true0 == '0' // true2 == true // false2 == false // falsefalse == 'false' // falsefalse == '0' // truefalse == undefined // falsefalse == null // falsenull == undefined // true' \\t\\r\\n ' == 0 // true 上面这些表达式都不同于直觉，很容易出错。因此建议不要使用相等运算符（==），最好只使用严格相等运算符（===）。 布尔运算符布尔运算符用于将表达式转为布尔值，一共包含四个运算符。 取反运算符：! 且运算符：&amp;&amp; 或运算符：|| 三元运算符：?: 取反运算符（!）对于非布尔值，取反运算符会将其转为布尔值。可以这样记忆，以下六个值取反后为true，其他值都为false。 undefined null false 0 NaN 空字符串（’’）12345678910!undefined // true!null // true!0 // true!NaN // true!\"\" // true!54 // false!'hello' // false![] // false!&#123;&#125; // false 且（或）运算符（&amp;&amp; ||）如果第一个运算子的布尔值为true，则返回第二个运算子的值（注意是值，不是布尔值）；如果第一个运算子的布尔值为false，则直接返回第一个运算子的值，且不再对第二个运算子求值。 或运算符（||）同理 也用于多个表达式的求值。它的运算规则是：如果第一个运算子的布尔值为true，则返回第一个运算子的值，且不再对第二个运算子求值；如果第一个运算子的布尔值为false，则返回第二个运算子的值。 神奇的JS123456789101112131415161718't' &amp;&amp; '' // \"\"'t' &amp;&amp; 'f' // \"f\"'t' &amp;&amp; (1 + 2) // 3'' &amp;&amp; 'f' // \"\"'' &amp;&amp; '' // \"\"'t' || '' // \"t\"'t' || 'f' // \"t\"'' || 'f' // \"f\"'' || '' // \"\"var x = 1;(1 - 1) &amp;&amp; ( x += 1) // 0x // 1var x = 1;true || (x = 2) // truex // 1 有些程序员喜欢用它取代if结构，比如下面是一段if结构的代码，就可以用且运算符改写。1234567if (i) &#123; doSomething();&#125;// 等价于i &amp;&amp; doSomething(); 或运算符常用于为一个变量设置默认值。1234567function saveText(text) &#123; text = text || ''; // ...&#125;// 或者写成saveText(this.text || '')","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://minoyu.github.io/tags/学习笔记/"},{"name":"《JavaScript 标准参考教程-阮一峰》","slug":"《JavaScript-标准参考教程-阮一峰》","permalink":"https://minoyu.github.io/tags/《JavaScript-标准参考教程-阮一峰》/"}]},{"title":"重学JS简略笔记01(基本语法、数据类型)","date":"2018-11-07T20:12:11.000Z","path":"2018/11/08/我的JavaScript简略学习笔记02-基本语法、数据类型/","text":"最近准备系统性的过一遍阮一峰的JavaScript教程，因为看的比较快速所以可能只能在这里简略的记录一些关键的地方了，希望这次能对JS的认识更全面一些吧。哈哈加油！那么下面开始咯。 总结自阮一峰JavaScript教程 基本语法一些概念最前面的var，是变量声明命令。它表示通知解释引擎，要创建一个变量a。1var a = 1; 注意，JavaScript 的变量名区分大小写，A和a是两个不同的变量。 如果只是声明变量而没有赋值，则该变量的值是undefined。undefined是一个特殊的值，表示“无定义”。 如果变量赋值的时候，忘了写var命令，这条语句也是有效的。123var a = 1;// 基本等同a = 1; 但是，不写var的做法，不利于表达意图，而且容易不知不觉地创建全局变量，所以建议总是使用var命令声明变量。 如果一个变量没有声明就直接使用，JavaScript 会报错，告诉你变量未定义。 JavaScript 是一种动态类型语言，也就是说，变量的类型没有限制，变量可以随时更改类型。 12var a = 1;a = 'hello'; 如果使用var重新声明一个已经存在的变量，是无效的。但是，如果第二次声明的时候还进行了赋值，则会覆盖掉前面的值。 变量提升JavaScript 引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升（hoisting）。 12console.log(a);var a = 1; 上面代码首先使用console.log方法，在控制台（console）显示变量a的值。这时变量a还没有声明和赋值，所以这是一种错误的做法，但是实际上不会报错。因为存在变量提升，真正运行的是下面的代码。 123var a;console.log(a);a = 1; 最后的结果是显示undefined，表示变量a已声明，但还未赋值。 标识符简单说，标识符命名规则如下。 第一个字符，可以是任意 Unicode 字母（包括英文字母和其他语言的字母），以及美元符号（$）和下划线（_）。 第二个字符及后面的字符，除了 Unicode 字母、美元符号和下划线，还可以用数字0-9。 JavaScript 有一些保留字，不能用作标识符：arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield。 区块JavaScript 使用大括号，将多个相关的语句组合在一起，称为“区块”（block）。 对于var命令来说，JavaScript 的区块不构成单独的作用域（scope）。12345&#123; var a = 1;&#125;a // 1 上面代码在区块内部，使用var命令声明并赋值了变量a，然后在区块外部，变量a依然有效，区块对于var命令不构成单独的作用域，与不使用区块的情况没有任何区别。在 JavaScript 语言中，单独使用区块并不常见，区块往往用来构成其他更复杂的语法结构，比如for、if、while、function等。 条件语句JavaScript 提供if结构和switch结构，完成条件判断，即只有满足预设的条件，才会执行相应的语句。 这部分简略 注意，if后面的表达式之中，不要混淆赋值表达式（=）、严格相等运算符（===）和相等运算符（==）。 至于为什么优先采用“严格相等运算符”（===），而不是“相等运算符”（==），请参考《运算符》章节。 循环语句while for do...while break 语句和 continue 语句不再详细介绍传送门 标签（label）JavaScript 语言允许，语句的前面有标签（label），相当于定位符，用于跳转到程序的任意位置，标签的格式如下。12label: 语句 标签可以是任意的标识符，但不能是保留字，语句部分可以是任意语句。 标签通常与break语句和continue语句配合使用，跳出特定的循环。 1234567891011top: for (var i = 0; i &lt; 3; i++)&#123; for (var j = 0; j &lt; 3; j++)&#123; if (i === 1 &amp;&amp; j === 1) break top; console.log('i=' + i + ', j=' + j); &#125; &#125;// i=0, j=0// i=0, j=1// i=0, j=2// i=1, j=0 上面代码为一个双重循环区块，break命令后面加上了top标签（注意，top不用加引号），满足条件时，直接跳出双层循环。如果break语句后面不使用标签，则只能跳出内层循环，进入下一次的外层循环。 标签也可以用于跳出代码块。 12345678foo: &#123; console.log(1); break foo; console.log('本行不会输出');&#125;console.log(2);// 1// 2 上面代码执行到break foo，就会跳出区块。 continue语句也可以与标签配合使用。1234567891011121314top: for (var i = 0; i &lt; 3; i++)&#123; for (var j = 0; j &lt; 3; j++)&#123; if (i === 1 &amp;&amp; j === 1) continue top; console.log('i=' + i + ', j=' + j); &#125; &#125;// i=0, j=0// i=0, j=1// i=0, j=2// i=1, j=0// i=2, j=0// i=2, j=1// i=2, j=2 上面代码中，continue命令后面有一个标签名，满足条件时，会跳过当前循环，直接进入下一轮外层循环。如果continue语句后面不使用标签，则只能进入下一轮的内层循环。 数据类型概述JavaScript 语言的每一个值，都属于某一种数据类型。JavaScript 的数据类型，共有六种。（ES6 又新增了第七种 Symbol 类型的值 数值（number）：整数和小数（比如1和3.14） 字符串（string）：文本（比如Hello World）。 布尔值（boolean）：表示真伪的两个特殊值，即true（真）和false（假） undefined：表示“未定义”或不存在，即由于目前没有定义，所以此处暂时没有任何值 null：表示空值，即此处的值为空。 对象（object）：各种值组成的集合。 通常，数值、字符串、布尔值这三种类型，合称为原始类型（primitive type）的值，即它们是最基本的数据类型，不能再细分了。 对象则称为合成类型（complex type）的值，因为一个对象往往是多个原始类型的值的合成，可以看作是一个存放各种值的容器。 至于undefined和null，一般将它们看成两个特殊值。 对象是最复杂的数据类型，又可以分成三个子类型。 狭义的对象（object） 数组（array） 函数（function） 狭义的对象和数组是两种不同的数据组合方式，除非特别声明，本教程的”对象“都特指狭义的对象。函数其实是处理数据的方法，JavaScript 把它当成一种数据类型，可以赋值给变量，这为编程带来了很大的灵活性，也为 JavaScript 的“函数式编程”奠定了基础。 typeof 运算符JavaScript 有三种方法，可以确定一个值到底是什么类型。 typeof运算符 instanceof运算符 Object.prototype.toString方法 12345678910typeof 123 // \"number\"typeof '123' // \"string\"typeof false // \"boolean\"function f() &#123;&#125;typeof f// \"function\"typeof undefined// \"undefined\" 利用这一点，typeof可以用来检查一个没有声明的变量，而不报错。 12345v// ReferenceError: v is not definedtypeof v// \"undefined\" 上面代码中，变量v没有用var命令声明，直接使用就会报错。但是，放在typeof后面，就不报错了，而是返回undefined。 实际编程中，这个特点通常用在判断语句。 12345678910// 错误的写法if (v) &#123; // ...&#125;// ReferenceError: v is not defined// 正确的写法if (typeof v === \"undefined\") &#123; // ...&#125; 对象返回object.123typeof window // \"object\"typeof &#123;&#125; // \"object\"typeof [] // \"object\" 上面代码中，空数组（[]）的类型也是object，这表示在 JavaScript 内部，数组本质上只是一种特殊的对象。这里顺便提一下，instanceof运算符可以区分数组和对象。instanceof运算符的详细解释，请见《面向对象编程》一章。 12345var o = &#123;&#125;;var a = [];o instanceof Array // falsea instanceof Array // true null返回object。 1typeof null // \"object\" null的类型是object，这是由于历史原因造成的。1995年的 JavaScript 语言第一版，只设计了五种数据类型（对象、整数、浮点数、字符串和布尔值），没考虑null，只把它当作object的一种特殊值。后来null独立出来，作为一种单独的数据类型，为了兼容以前的代码，typeof null返回object就没法改变了。 null 和 undefinednull与undefined都可以表示“没有”，含义非常相似。将一个变量赋值为undefined或null，老实说，语法效果几乎没区别。 在if语句中，它们都会被自动转为false，相等运算符（==）甚至直接报告两者相等。 123456789101112if (!undefined) &#123; console.log('undefined is false');&#125;// undefined is falseif (!null) &#123; console.log('null is false');&#125;// null is falseundefined == null// true 从上面代码可见，两者的行为是何等相似！谷歌公司开发的 JavaScript 语言的替代品 Dart 语言，就明确规定只有null，没有undefined！ 既然含义与用法都差不多，为什么要同时设置两个这样的值，这不是无端增加复杂度，令初学者困扰吗？这与历史原因有关。1995年 JavaScript 诞生时，最初像 Java 一样，只设置了null表示”无”。根据 C 语言的传统，null可以自动转为0。 12Number(null) // 05 + null // 5 但是，JavaScript 的设计者 Brendan Eich，觉得这样做还不够。首先，第一版的 JavaScript 里面，null就像在 Java 里一样，被当成一个对象，Brendan Eich 觉得表示“无”的值最好不是对象。其次，那时的 JavaScript 不包括错误处理机制，Brendan Eich 觉得，如果null自动转为0，很不容易发现错误。 因此，他又设计了一个undefined。区别是这样的：null是一个表示“空”的对象，转为数值时为0；undefined是一个表示”此处无定义”的原始值，转为数值时为NaN。 12Number(undefined) // NaN5 + undefined // NaN 用法和定义null表示空值，即该处的值现在为空。调用函数时，某个参数未设置任何值，这时就可以传入null，表示该参数为空。比如，某个函数接受引擎抛出的错误作为参数，如果运行过程中未出错，那么这个参数就会传入null，表示未发生错误。 undefined表示“未定义”。1234567891011121314151617// 变量声明了，但没有赋值var i;i // undefined// 调用函数时，应该提供的参数没有提供，该参数等于 undefinedfunction f(x) &#123; return x;&#125;f() // undefined// 对象没有赋值的属性var o = new Object();o.p // undefined// 函数没有返回值时，默认返回 undefinedfunction f() &#123;&#125;f() // undefined 布尔值“真”用关键字true表示，“假”用关键字false表示。布尔值只有这两个值。 下列运算符会返回布尔值： 前置逻辑运算符： ! (Not) 相等运算符：===，!==，==，!= 比较运算符：&gt;，&gt;=，&lt;，&lt;= 如果 JavaScript 预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。转换规则是除了下面六个值被转为false，其他值都视为true。 undefined null false 0 NaN “”或’’（空字符串） 注意，空数组（[]）和空对象（{}）对应的布尔值，都是true。 数值概述整数和浮点数JavaScript 内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。所以，1与1.0是相同的，是同一个数。 11 === 1.0 // true 这就是说，JavaScript 语言的底层根本没有整数，所有数字都是小数（64位浮点数）。由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心。 123456780.1 + 0.2 === 0.3// false0.3 / 0.1// 2.9999999999999996(0.3 - 0.2) === (0.2 - 0.1)// false 数值精度根据国际标准 IEEE 754，JavaScript 浮点数的64个二进制位，从最左边开始，是这样组成的。 第1位：符号位，0表示正数，1表示负数 第2位到第12位（共11位）：指数部分 第13位到第64位（共52位）：小数部分（即有效数字） 符号位决定了一个数的正负，指数部分决定了数值的大小，小数部分决定了数值的精度。 指数部分一共有11个二进制位，因此大小范围就是0到2047。IEEE 754 规定，如果指数部分的值在0到2047之间（不含两个端点），那么有效数字的第一位默认总是1，不保存在64位浮点数之中。也就是说，有效数字这时总是1.xx…xx的形式，其中xx..xx的部分保存在64位浮点数之中，最长可能为52位。因此，JavaScript 提供的有效数字最长为53个二进制位。 精度最多只能到53个二进制位，这意味着，绝对值小于2的53次方的整数，即-253到253，都可以精确表示。 1234567891011121314Math.pow(2, 53)// 9007199254740992 Math.pow(2, 53) + 1// 9007199254740992Math.pow(2, 53) + 2// 9007199254740994Math.pow(2, 53) + 3// 9007199254740996Math.pow(2, 53) + 4// 9007199254740996 上面代码中，大于2的53次方以后，整数运算的结果开始出现错误。所以，大于2的53次方的数值，都无法保持精度。由于2的53次方是一个16位的十进制数值，所以简单的法则就是，JavaScript 对15位的十进制数都可以精确处理。 数值范围根据标准，64位浮点数的指数部分的长度是11个二进制位，意味着指数部分的最大值是2047（2的11次方减1）。也就是说，64位浮点数的指数部分的值最大为2047，分出一半表示负数，则 JavaScript 能够表示的数值范围为21024到2-1023（开区间），超出这个范围的数无法表示 如果一个数大于等于2的1024次方，那么就会发生“正向溢出”，即 JavaScript 无法表示这么大的数，这时就会返回Infinity。 1Math.pow(2, 1024) // Infinity 如果一个数小于等于2的-1075次方（指数部分最小值-1023，再加上小数部分的52位），那么就会发生为“负向溢出”，即 JavaScript 无法表示这么小的数，这时会直接返回0。1Math.pow(2, -1075) // 0 JavaScript 提供Number对象的MAX_VALUE和MIN_VALUE属性，返回可以表示的具体的最大值和最小值。 12Number.MAX_VALUE // 1.7976931348623157e+308Number.MIN_VALUE // 5e-324 数值的表示法JavaScript 的数值有多种表示方法，可以用字面形式直接表示，比如35（十进制）和0xFF（十六进制）。数值也可以采用科学计数法表示.1234123e3 // 123000123e-3 // 0.123-3.1E+12.1e-23 小数点前的数字多于21位 或 小数点后的零多于5个 两种情况下，JavaScript 会自动将数值转为科学计数法表示，其他情况都采用字面形式直接表示。 数值的进制 十进制：没有前导0的数值。 八进制：有前缀0o或0O的数值，或者有前导0、且只用到0-7的八个阿拉伯数字的数值。 十六进制：有前缀0x或0X的数值。 二进制：有前缀0b或0B的数值。 前导0表示八进制，处理时很容易造成混乱。ES5 的严格模式和 ES6，已经废除了这种表示法，但是浏览器为了兼容以前的代码，目前还继续支持这种表示法。 特殊数值JavaScript 提供了几个特殊的数值。 正零和负零JavaScript 内部实际上存在2个0：一个是+0，一个是-0，区别就是64位浮点数表示法的符号位不同。它们是等价的。123-0 === +0 // true0 === -0 // true0 === +0 // true 几乎所有场合，正零和负零都会被当作正常的0。唯一有区别的场合是，+0或-0当作分母，返回的值是不相等的。之所以出现这样结果，是因为除以正零得到+Infinity，除以负零得到-Infinity，这两者是不相等的 12345+0 // 0-0 // 0(-0).toString() // '0'(+0).toString() // '0'(1 / +0) === (1 / -0) // false NaN含义NaN是 JavaScript 的特殊值，表示“非数字”（Not a Number），主要出现在将字符串解析成数字出错的场合。 15 - 'x' // NaN 另外，一些数学函数的运算结果会出现NaN。123Math.acos(2) // NaNMath.log(-1) // NaNMath.sqrt(-1) // NaN 0除以0也会得到NaN。10/0//NaN 需要注意的是，NaN不是独立的数据类型，而是一个特殊数值，它的数据类型依然属于Number。1typeof NaN // 'number' 运算规则NaN不等于任何值，包括它本身。1NaN === NaN // false 数组的indexOf方法内部使用的是严格相等运算符，所以该方法对NaN不成立。1[NaN].indexOf(NaN) // -1 NaN在布尔运算时被当作false。1Boolean(NaN) // false NaN与任何数（包括它自己）的运算，得到的都是NaN。1234NaN + 32 // NaNNaN - 32 // NaNNaN * 32 // NaNNaN / 32 // NaN Infinity含义Infinity表示“无穷”，用来表示两种场景。一种是一个正的数值太大，或一个负的数值太小，无法表示；另一种是非0数值除以0，得到Infinity。 Infinity有正负之分，Infinity表示正的无穷，-Infinity表示负的无穷。1234Infinity === -Infinity // false1 / -0 // -Infinity-1 / -0 // Infinity Infinity大于一切数值（除了NaN），-Infinity小于一切数值（除了NaN）。 Infinity与NaN比较，总是返回false。12345Infinity &gt; NaN // false-Infinity &gt; NaN // falseInfinity &lt; NaN // false-Infinity &lt; NaN // false 运算规则Infinity的四则运算，符合无穷的数学计算规则。12345 * Infinity // Infinity5 - Infinity // -InfinityInfinity / 5 // Infinity5 / Infinity // 0 0乘以Infinity，返回NaN；0除以Infinity，返回0；Infinity除以0，返回Infinity。 Infinity加上或乘以Infinity，返回的还是Infinity。 Infinity减去或除以Infinity，得到NaN。 Infinity与null计算时，null会转成0，等同于与0的计算。123null * Infinity // NaNnull / Infinity // 0Infinity / null // Infinity Infinity与undefined计算，返回的都是NaN。 与数值相关的全局方法parseInt()用于将字符串转为整数。详细用法 parseFloat()parseFloat方法用于将一个字符串转为浮点数。详细用法 isNaN()isNaN方法可以用来判断一个值是否为NaN。12isNaN(NaN) // trueisNaN(123) // false 但是，isNaN只对数值有效，如果传入其他值，会被先转成数值。比如，传入字符串的时候，字符串会被先转成NaN，所以最后返回true，这一点要特别引起注意。也就是说，isNaN为true的值，有可能不是NaN，而是一个字符串。 出于同样的原因，对于对象和数组，isNaN也返回true。 但是，对于空数组和只有一个数值成员的数组，isNaN返回false。 详细用法 isFinite()isFinite方法返回一个布尔值，表示某个值是否为正常的数值。 除了Infinity、-Infinity、NaN和undefined这几个值会返回false，isFinite对于其他的数值都会返回true。 123456isFinite(Infinity) // falseisFinite(-Infinity) // falseisFinite(NaN) // falseisFinite(undefined) // falseisFinite(null) // trueisFinite(-1) // true 字符串js的字符串可以放在单引号和双引号中 单引号字符串的内部，可以使用双引号。双引号字符串的内部，可以使用单引号。 12'key = \"value\"'\"It's a long journey\" 上面两个都是合法的字符串。 如果要在单引号字符串的内部，使用单引号，就必须在内部的单引号前面加上反斜杠(\\)，用来转义。 字符串默认只能写在一行内，分成多行将会报错。 如果长字符串必须分成多行，可以在每一行的尾部使用反斜杠。注意，反斜杠的后面必须是换行符，而不能有其他字符（比如空格），否则会报错。 转义需要用反斜杠转义的特殊字符，主要有下面这些。 \\0 ：null（\\u0000） \\b ：后退键（\\u0008） \\f ：换页符（\\u000C） \\n ：换行符（\\u000A） \\r ：回车键（\\u000D） \\t ：制表符（\\u0009） \\v ：垂直制表符（\\u000B） \\&#39; ：单引号（\\u0027） \\&quot; ：双引号（\\u0022） \\\\ ：反斜杠（\\u005C） 字符串与数组字符串可以被视为字符数组，因此可以使用数组的方括号运算符，用来返回某个位置的字符（位置编号从0开始）。 但是，字符串与数组的相似性仅此而已。实际上，无法改变字符串之中的单个字符。 length 属性length属性返回字符串的长度，该属性也是无法改变的。 字符集JavaScript 使用 Unicode 字符集。JavaScript 引擎内部，所有字符都用 Unicode 表示。详细 Base64转码有时，文本里面包含一些不可打印的符号，比如 ASCII 码0到31的符号都无法打印出来，这时可以使用 Base64 编码，将它们转成可以打印的字符。另一个场景是，有时需要以文本格式传递二进制数据，那么也可以使用 Base64 编码。 所谓 Base64 就是一种编码方法，可以将任意值转成 0～9、A～Z、a-z、+和/这64个字符组成的可打印字符。使用它的主要目的，不是为了加密，而是为了不出现特殊字符，简化程序的处理。 两个 Base64 相关的方法。 btoa()：任意值转为 Base64 编码 atob()：Base64 编码转为原来的值 注意，这两个方法不适合非 ASCII 码的字符（如中文），会报错。 要将非 ASCII 码字符转为 Base64 编码，必须中间插入一个转码环节，再使用这两个方法。 12345678910function b64Encode(str) &#123; return btoa(encodeURIComponent(str));&#125;function b64Decode(str) &#123; return decodeURIComponent(atob(str));&#125;b64Encode('你好') // \"JUU0JUJEJUEwJUU1JUE1JUJE\"b64Decode('JUU0JUJEJUEwJUU1JUE1JUJE') // \"你好\" 有关URI编码的详解 对象概述生成方法简单说，对象就是一组“键值对”（key-value）的集合，是一种无序的复合数据集合。1234var obj = &#123; foo: 'Hello', bar: 'World'&#125;; 键名 对象的所有键名都是字符串（ES6 又引入了 Symbol 值也可以作为键名），所以加不加引号都可以。 如果键名是数值，会被自动转为字符串。 如果键名不符合标识名的条件（比如第一个字符为数字，或者含有空格或运算符），且也不是数字，则必须加上引号，否则会报错。 对象的每一个键名又称为“属性”（property），它的“键值”可以是任何数据类型。如果一个属性的值为函数，通常把这个属性称为“方法”，它可以像函数那样调用。 1234567var obj = &#123; p: function (x) &#123; return 2 * x; &#125;&#125;;obj.p(1) // 2 如果属性的值还是一个对象，就形成了链式引用。 12345var o1 = &#123;&#125;;var o2 = &#123; bar: 'hello' &#125;;o1.foo = o2;o1.foo.bar // \"hello\" 就像上面那样，属性可以动态创建，不必在对象声明时就指定。 对象的引用 如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有变量。 表达式还是语句？对象采用大括号表示，这导致了一个问题：如果行首是一个大括号，它到底是表达式还是语句？ 1&#123; foo: 123 &#125; JavaScript 引擎读到上面这行代码，会发现可能有两种含义。第一种可能是，这是一个表达式，表示一个包含foo属性的对象；第二种可能是，这是一个语句，表示一个代码区块，里面有一个标签foo，指向表达式123。 为了避免这种歧义，V8 引擎规定，如果行首是大括号，一律解释为对象。不过，为了避免歧义，最好在大括号前加上圆括号。 1(&#123; foo: 123&#125;) 属性的操作属性的读取读取对象的属性，有两种方法，一种是使用点运算符，还有一种是使用方括号运算符。 请注意，如果使用方括号运算符，键名必须放在引号里面，否则会被当作变量处理。 数字键可以不加引号，因为会自动转成字符串。数值键名不能使用点运算符（因为会被当成小数点），只能使用方括号运算符。 属性的查看查看一个对象本身的所有属性，可以使用Object.keys方法。 属性的删除：delete 命令delete命令用于删除对象的属性，删除成功后返回true。123456var obj = &#123; p: 1 &#125;;Object.keys(obj) // [\"p\"]delete obj.p // trueobj.p // undefinedObject.keys(obj) // [] 注意，删除一个不存在的属性，delete不报错，而且返回true。 只有一种情况，delete命令会返回false，那就是该属性存在，且不得删除。 1234567var obj = Object.defineProperty(&#123;&#125;, 'p', &#123; value: 123, configurable: false&#125;);obj.p // 123delete obj.p // false 另外，需要注意的是，delete命令只能删除对象本身的属性，无法删除继承的属性。 属性是否存在：in 运算符in运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值），如果包含就返回true，否则返回false。它的左边是一个字符串，表示属性名，右边是一个对象。123var obj = &#123; p: 1 &#125;;'p' in obj // true'toString' in obj // true in运算符的一个问题是，它不能识别哪些属性是对象自身的，哪些属性是继承的。这时，可以使用对象的hasOwnProperty方法判断一下，是否为对象自身的属性。 属性的遍历：for…in 循环for…in循环用来遍历一个对象的全部属性。123456789101112var obj = &#123;a: 1, b: 2, c: 3&#125;;for (var i in obj) &#123; console.log('键名：', i); console.log('键值：', obj[i]);&#125;// 键名： a// 键值： 1// 键名： b// 键值： 2// 键名： c// 键值： 3 for…in循环有两个使用注意点。 它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性。 它不仅遍历对象自身的属性，还遍历继承的属性。 with语句with语句的格式如下：123with (对象) &#123; 语句;&#125; 它的作用是操作同一个对象的多个属性时，提供一些书写的方便。1234567891011121314151617181920212223// 例一var obj = &#123; p1: 1, p2: 2,&#125;;with (obj) &#123; p1 = 4; p2 = 5;&#125;// 等同于obj.p1 = 4;obj.p2 = 5;// 例二with (document.links[0])&#123; console.log(href); console.log(title); console.log(style);&#125;// 等同于console.log(document.links[0].href);console.log(document.links[0].title);console.log(document.links[0].style); 注意，如果with区块内部有变量的赋值操作，必须是当前对象已经存在的属性，否则会创造一个当前作用域的全局变量。 函数作用域作用域（scope）指的是变量存在的范围。在 ES5 的规范中，Javascript 只有两种作用域：一种是全局作用域，变量在整个程序中一直存在，所有地方都可以读取；另一种是函数作用域，变量只在函数内部存在。 ES6 又新增了块级作用域 函数内部定义的变量，会在该作用域内覆盖同名全局变量。 注意，对于var命令来说，局部变量只能在函数内部声明，在其他区块中声明，一律都是全局变量。 函数内部的变量提升与全局作用域一样，函数作用域内部也会产生“变量提升”现象.var命令声明的变量，不管在什么位置，变量声明都会被提升到函数体的头部。 函数本身的作用域函数本身也是一个值，也有自己的作用域。它的作用域与变量一样，就是其声明时所在的作用域，与其运行时所在的作用域无关。 1234567891011var a = 1;var x = function () &#123; console.log(a);&#125;;function f() &#123; var a = 2; x();&#125;f() // 1 上面代码中，函数x是在函数f的外部声明的，所以它的作用域绑定外层，内部变量a不会到函数f体内取值，所以输出1，而不是2。 总之，函数执行时所在的作用域，是定义时的作用域，而不是调用时所在的作用域。 同样的，函数体内部声明的函数，作用域绑定函数体内部。 1234567891011function foo() &#123; var x = 1; function bar() &#123; console.log(x); &#125; return bar;&#125;var x = 2;var f = foo();f() // 1 上面代码中，函数foo内部声明了一个函数bar，bar的作用域绑定foo。当我们在foo外部取出bar执行时，变量x指向的是foo内部的x，而不是foo外部的x。正是这种机制，构成了下文要讲解的“闭包”现象。 参数参数的省略 函数参数不是必需的，Javascript 允许省略参数，不会报错。 省略的参数的值就变为undefined。需要注意的是，函数的length属性与实际传入的参数个数无关，只反映函数预期传入的参数个数。 但是，没有办法只省略靠前的参数，而保留靠后的参数。如果一定要省略靠前的参数，只有显式传入undefined。 传递方式 函数参数如果是原始类型的值（数值、字符串、布尔值），传递方式是传值传递（passes by value）。这意味着，在函数体内修改参数值，不会影响到函数外部。 如果函数参数是复合类型的值（数组、对象、其他函数），传递方式是传址传递（pass by reference）。也就是说，传入函数的原始值的地址，因此在函数内部修改参数，将会影响到原始值。 注意，如果函数内部修改的，不是参数对象的某个属性，而是替换掉整个参数，这时不会影响到原始值。12345678var obj = [1, 2, 3];function f(o) &#123; o = [2, 3, 4];&#125;f(obj);obj // [1, 2, 3] 上面代码中，在函数f内部，参数对象obj被整个替换成另一个值。这时不会影响到原始值。这是因为，形式参数（o）的值实际是参数obj的地址，重新对o赋值导致o指向另一个地址，保存在原地址上的值当然不受影响。 同名参数如果有同名的参数，则取最后出现的那个值。 12345function f(a, a) &#123; console.log(a);&#125;f(1) // undefined 调用函数f的时候，没有提供第二个参数，a的取值就变成了undefined。这时，如果要获得第一个a的值，可以使用arguments对象。12345function f(a, a) &#123; console.log(arguments[0]);&#125;f(1) // 1 arguments 对象由于 JavaScript 允许函数有不定数目的参数，所以需要一种机制，可以在函数体内部读取所有参数。这就是arguments对象的由来。 arguments对象包含了函数运行时的所有参数，arguments[0]就是第一个参数，arguments[1]就是第二个参数，以此类推。这个对象只有在函数体内部，才可以使用。 正常模式下，arguments对象可以在运行时修改。 1234567var f = function(a, b) &#123; arguments[0] = 3; arguments[1] = 2; return a + b;&#125;f(1, 1) // 5 严格模式下，arguments对象是一个只读对象，修改它是无效的，但不会报错。 12345678var f = function(a, b) &#123; 'use strict'; // 开启严格模式 arguments[0] = 3; // 无效 arguments[1] = 2; // 无效 return a + b;&#125;f(1, 1) // 2 上面代码中，函数体内是严格模式，这时修改arguments对象就是无效的。 通过arguments对象的length属性，可以判断函数调用时到底带几个参数。 与数组的关系需要注意的是，虽然arguments很像数组，但它是一个对象。数组专有的方法（比如slice和forEach），不能在arguments对象上直接使用。 如果要让arguments对象使用数组方法，真正的解决方法是将arguments转为真正的数组。下面是两种常用的转换方法：slice方法和逐一填入新数组。 1234567var args = Array.prototype.slice.call(arguments);// 或者var args = [];for (var i = 0; i &lt; arguments.length; i++) &#123; args.push(arguments[i]);&#125; callee 属性arguments对象带有一个callee属性，返回它所对应的原函数。 闭包前面提到，JavaScript 有两种作用域：全局作用域和函数作用域。函数内部可以直接读取全局变量。但是，函数外部无法读取函数内部声明的变量。 如果出于种种原因，需要得到函数内的局部变量。正常情况下，这是办不到的，只有通过变通方法才能实现。那就是在函数的内部，再定义一个函数。 123456function f1() &#123; var n = 999; function f2() &#123; console.log(n); // 999 &#125;&#125; 既然f2可以读取f1的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！ 12345678910function f1() &#123; var n = 999; function f2() &#123; console.log(n); &#125; return f2;&#125;var result = f1();result(); // 999 上面代码中，函数f1的返回值就是函数f2，由于f2可以读取f1的内部变量，所以就可以在外部获得f1的内部变量了。 闭包就是函数f2，即能够读取其他函数内部变量的函数。由于在 JavaScript 语言中，只有函数内部的子函数才能读取内部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。 闭包最大的特点，就是它可以“记住”诞生的环境，比如f2记住了它诞生的环境f1，所以从f2可以得到f1的内部变量。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 闭包的最大用处有两个 一个是可以读取函数内部的变量 另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。请看下面的例子，闭包使得内部变量记住上一次调用时的运算结果。1234567891011function createIncrementor(start) &#123; return function () &#123; return start++; &#125;;&#125;var inc = createIncrementor(5);inc() // 5inc() // 6inc() // 7 为什么会这样呢？原因就在于inc始终在内存中，而inc的存在依赖于createIncrementor，因此也始终在内存中，不会在调用结束后，被垃圾回收机制回收。 闭包的另一个用处，是封装对象的私有属性和私有方法。12345678910111213141516171819function Person(name) &#123; var _age; function setAge(n) &#123; _age = n; &#125; function getAge() &#123; return _age; &#125; return &#123; name: name, getAge: getAge, setAge: setAge &#125;;&#125;var p1 = Person('张三');p1.setAge(25);p1.getAge() // 25 上面代码中，函数Person的内部变量_age，通过闭包getAge和setAge，变成了返回对象p1的私有变量。 注意，外层函数每次运行，都会生成一个新的闭包，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大。因此不能滥用闭包，否则会造成网页的性能问题。 立即调用的函数表达式（IIFE)在 Javascript 中，圆括号()是一种运算符，跟在函数名之后，表示调用该函数。比如，print()就表示调用print函数。 123(function()&#123; /* code */ &#125;());// 或者(function()&#123; /* code */ &#125;)(); 这就叫做“立即调用的函数表达式”（Immediately-Invoked Function Expression） 上面两种写法都是以圆括号开头，引擎就会认为后面跟的是一个表示式，而不是函数定义语句. 通常情况下，只对匿名函数使用这种“立即执行的函数表达式”。它的目的有两个：一是不必为函数命名，避免了污染全局变量；二是 IIFE 内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。1234567891011// 写法一var tmp = newData;processData(tmp);storeData(tmp);// 写法二(function () &#123; var tmp = newData; processData(tmp); storeData(tmp);&#125;()); 上面代码中，写法二比写法一更好，因为完全避免了污染全局变量。 数组 任何类型的数据，都可以放入数组。123456789var arr = [ &#123;a: 1&#125;, [1, 2, 3], function() &#123;return true;&#125;];arr[0] // Object &#123;a: 1&#125;arr[1] // [1, 2, 3]arr[2] // function ()&#123;return true;&#125; 上面数组arr的3个成员依次是对象、数组、函数。 如果数组的元素还是数组，就形成了多维数组。 本质上，数组属于一种特殊的对象。typeof运算符会返回数组的类型是object。数组的特殊性体现在，它的键名是按次序排列的一组整数（0，1，2…）1234var arr = ['a', 'b', 'c'];Object.keys(arr)// [\"0\", \"1\", \"2\"] 对象有两种读取成员的方法：点结构（object.key）和方括号结构（object[key]）。但是，对于数值的键名，不能使用点结构。 length属性数组的length属性，返回数组的成员数量。 但需要注意的是，数组的数字键不需要连续，length属性的值总是比最大的那个整数键大1。1234567891011var arr = ['a', 'b'];arr.length // 2arr[2] = 'c';arr.length // 3arr[9] = 'd';arr.length // 10arr[1000] = 'e';arr.length // 1001 length属性是可写的。如果人为设置一个小于当前成员个数的值，该数组的成员会自动减少到length设置的值。清空数组的一个有效方法，就是将length属性设为0。 12345var arr = [ 'a', 'b', 'c' ];arr.length // 3arr.length = 2;arr // [\"a\", \"b\"] in运算符检查某个键名是否存在的运算符in，适用于对象，也适用于数组。1234var arr = [ 'a', 'b', 'c' ];2 in arr // true'2' in arr // true4 in arr // false for…in 循环和数组的遍历for…in循环不仅可以遍历对象，也可以遍历数组，毕竟数组只是一种特殊对象。12345678var a = [1, 2, 3];for (var i in a) &#123; console.log(a[i]);&#125;// 1// 2// 3 但是，for…in不仅会遍历数组所有的数字键，还会遍历非数字键。 所以，不推荐使用for…in遍历数组。数组的遍历可以考虑使用for循环或while循环。 数组的forEach方法，也可以用来遍历数组，详见《标准库》的 Array 对象一章 1234567var colors = ['red', 'green', 'blue'];colors.forEach(function (color) &#123; console.log(color);&#125;);// red// green// blue 空位length属性不过滤空位。所以，使用length属性进行数组遍历，一定要非常小心。 数组的某个位置是空位，与某个位置是undefined，是不一样的。如果是空位，使用数组的forEach方法、for…in结构、以及Object.keys方法进行遍历，空位都会被跳过。 这就是说，空位就是数组没有这个元素，所以不会被遍历到，而undefined则表示数组有这个元素，值是undefined，所以遍历不会跳过。 类似数组的对象数组的slice方法可以将“类似数组的对象”变成真正的数组。1var arr = Array.prototype.slice.call(arrayLike); “类似数组的对象”还有一个办法可以使用数组的方法，就是通过call()把数组的方法放到对象上面。 12345function print(value, index) &#123; console.log(index + ' : ' + value);&#125;Array.prototype.forEach.call(arrayLike, print); 上面代码中，arrayLike代表一个类似数组的对象，本来是不可以使用数组的forEach()方法的，但是通过call()，可以把forEach()嫁接到arrayLike上面调用。 下面的例子就是通过这种方法，在arguments对象上面调用forEach方法。12345678910111213// forEach 方法function logArgs() &#123; Array.prototype.forEach.call(arguments, function (elem, i) &#123; console.log(i + '. ' + elem); &#125;);&#125;// 等同于 for 循环function logArgs() &#123; for (var i = 0; i &lt; arguments.length; i++) &#123; console.log(i + '. ' + arguments[i]); &#125;&#125; 字符串也是类似数组的对象，所以也可以用Array.prototype.forEach.call遍历。 注意，这种方法比直接使用数组原生的forEach要慢，所以最好还是先将“类似数组的对象”转为真正的数组，然后再直接调用数组的forEach方法。123456789//callArray.prototype.forEach.call('abc', function (chr) &#123; console.log(chr);&#125;);//slicevar arr = Array.prototype.slice.call('abc');arr.forEach(function (chr) &#123; console.log(chr);&#125;);","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://minoyu.github.io/tags/学习笔记/"},{"name":"《JavaScript 标准参考教程-阮一峰》","slug":"《JavaScript-标准参考教程-阮一峰》","permalink":"https://minoyu.github.io/tags/《JavaScript-标准参考教程-阮一峰》/"}]},{"title":"Core Java Day5--基本编程结构5(数组与数组列表、方法)","date":"2018-10-28T13:52:45.000Z","path":"2018/10/28/Core-Java-Day5-基本编程结构5/","text":"1.8 数组与数组列表数组是收集相同类型多个元素的基本编程结构。 Java内置了数组类型，并且也提供根据需求随时增长或缩减的ArrayList类。 ArrayList是集合框架中的一部分，在这本书的后面会有讲到 使用数组对所有的类型都有相应的数组类型，例如int[],String[]. 和Ｃ语言的数组不太相同，java中的声明方式：1234567//数组变量的声明String[] names;//变量的初始化，我们用一个新的数组去初始化它。因此我们用到new 操作符names = new String[100];//声明和初始化可以放在一起String[] names = new String[100];//现在names引用一个有100个元素的数组了，合法下标范围0~99 使用C语言中的语法来声明数组变量(int nums[])也是合法的，但不够清晰，Java中一般不用这种方式。 如果下标越界，会抛出ArrayIndexOutOfBoundException异常 可以用 数组名.length 获得数组的长度(个数，如上面的100)1234//用空字符串填充数组for(int i = 0;i&lt;names.length;i++)&#123; names[i]=\"\";&#125; 构造数组当你使用操作符new构造数组时，会用默认值填充数组 数字类型 (包括char类型)的数组用0填充 Boolean类型的数组用false填充 对象数组用空引用填充 警告：任何时候，当构造对象数组时，需要使用对象填充数组。考虑这种声明123BigInteger[] numbers = new BigInteger[100];//此刻 你还没有任何BigInteger 仅是一个100个空引用的数组。//你需要用BigInteger对象的引用代替他们 你可以写个循环用值填充数组，你也可以将他们列在括号中1234int[] primes = &#123;2,3,5,7,11,13&#125;//不用使用new操作符，不用指定数组长度//如果你不想给数组名称，则可以使用类似的语法，给已存在的数组变量赋值primes = new int[]&#123;2,3,5,7,11,13&#125; 注意，允许数组长度为0，但长度为0的数组与null不同，与之前的空字符串与null不同类似。 数组列表构造数组时，你需要知道数组的长度。一旦构造后，数组的长度不能改变。 解决这种问题的方法就是使用java,util包中的ArrayList类。ArrayList对象内部管理数组。 当数组太小或者不够使用时，自动创建好另外一个内部数组，并且将元素移动到该数组。这个过程对使用数组列表的程序员是不可见。 数组和数组列表的语法完全不同，在数组中使用特殊的语法————[]操作符访问元素，使用Type[]语法获取数组类型，使用new Type[n]语法构造数组。相比之下，数组列表类，你可以使用构造实例和调用的语法。 ArraryList类是泛型类，这是一种带有类型参数的类。在这本书的后面会讲到。 使用泛型类语法，在尖括号中指定类型，声明一个数组列表变量：1234ArrayList&lt;String&gt; friends;//上面只是声明了变量。你现在需要构建数组列表：friends = new ArrayList&lt;&gt;; //或者new ArrayList&lt;String&gt;() 注意空的&lt;&gt; ，编译器会从变量的声明推断出类型参数（被称为钻石语法） 该调用中没有构造参数，但依然必须在末尾提供()。结果为一个大小为0的数组列表。 123456789101112131415161718//可以通过add方法给末尾添加元素。friends.add(\"Peter\");friends.add(\"Mino\");//可以在列表的任何位置添加或删除元素freinds.remove(1);friends.add(0,\"Paul\")//需要使用方法调用访问元素，get方法读取元素，set方法将元素//用另外一个代替：String first = friends.get(0);friends.set(1,\"Mary\");//size方法返回列表当前的大小。//可以使用下面的循环遍历数组列表中的所有元素。for (int i=0;i&lt;friends.size();i++)&#123; System.out.println(friends.get(i));&#125; 基本类型包装类！你不能使用基本类型作为类型参数，例如ArrayList是非法的。你必须使用包装类。 每一种基本类型，都有对应的包装类，Integer、Byte、Short、Long、Character、Float、Double和Boolean。 所以刚才那种要收集整数的数组列表可以写成ArrayList&lt;Integer&gt;. 123ArrayList&lt;Integer&gt; numbers = new ArrayList&lt;&gt;();numbers.add(42);int first = numbers.get(0); 基本类型和他们对应的包装类之间的转换是自动进行的。 在调用add方法时，一个值为42的Integer类对象在一种被称为自动装箱的过程中自动构造了。 在代码的最后一行，get调用返回一个Integer对象，在变量赋值之前自动拆箱，内部产生一个int值 像字符串一样，比较两个包装类是否相等时不可使用==和!= 记得调用包装类的equals方法 增强for循环你可能想经常遍历数组的所有元素，例如：123456789101112int sum = 0;for(int i = 0;i&lt;numbers.length;i++)&#123; sum += numbers[i];&#125;//还有种更普遍的方式，成为增强循环int sum = 0;for (int n :numbers)&#123; sum +=n;&#125;//变量n被复制为每次的循环项 数组与数组列表的复制你可以将数组变量复制到另外一个数组变量，但是那样两个变量引用同一个数组（共享的数组）,可以理解为数组变量保存的是一个地址，例如：123456int[] numbers = primes;numbers[5] = 42;//数组列表引用的也是同样的工作方式ArrayList&lt;String&gt; people = friends;people.set(0,\"Merry\");//于是现在friends中的第一个元素也是Merry 如果你不想要这种共享数组，则需要复制数组，可以使用静态方法Array.copyOf(被复制的数组，被复制的数组长度)。12345int[] copiedPrimes = Arrays.copyOf(primes,primes.length);//该方法会构造一个新数组，并将原数组的元素复制进去//对于数组列表，可直接从已存在的数组列表构造一个新的数组列表ArrayList&lt;String&gt; copiedFriends = new ArrayList&lt;&gt;(friends); 构造函数也可以将数组复制到数组列表，首先使用Arrays.asList方法，将数组包装到列表中。 1ArrayList&lt;String&gt; copiedFriends = new ArrayList&lt;&gt;(Arrays.asList(names)); Arrays.asList可以接受一个数组或任意数量的参数。 使用任意变量的参数时可以将它当做数组初始化语法的一种替代12Arrays.asList(names);Arrays.asList(\"Mino\",\"Paul\",\"Mary\"); 也可以将数组列表复制到数组中，必须提供正确类型的数组1String[] names = friends.toArray(new String[0]); 没有一种容易的方式可以完成基本类型数组和对应的包装类数组列表之间转换。例如：要在int[]和ArrayList&lt;Integer&gt;之间转换，你需要循环或者IntStream(这本书之后会讲到)。 数组方法Arrays（数组）类和Collection（集合）类实现了数组和数组列表的常用方法。12345678910111213141516171819//fill方法，填充数组或数组列表Arrays.fill(numbers,0);//int[]数组Collections.fill(friends,\"\")//ArrayList&lt;String&gt;//sort 方法 排个序Arrays.sort(numbers);Collections.sort(friends);//Array.toString方法产生一个数组的字符串表示。//调试时要输出数组该方法特别管用System.out.pintln(Arrays.toString(nums));//数组列表对象也有个toString方法friends.toString();//PS. println方法输出时会自动调用toString()方法System.out.println(friends);//数组列表还有一对有用的方法，数组没有对应的方法Collections.reverse(names);//反转元素Collections.shuffle(names);//随机打乱元素 命令行参数所有java程序的main方法都有一个字符串数组的参数：123public static void main(String[] args)&#123; ...&#125; 12345//当程序执行时 在命令行中指定的参数就复制给args//如果程序在命令行中以如下方式调用java Greeting hello world//Greeting是类名 而后面的参数以空格分割开。//所以args[0]为\"hello\" args[1]为\"world\" 多维数组Java没有真实的多维数组，对维数组是通过数组的数组来实现的。例如 声明一个对维数组：123456int[][] square = &#123; &#123;1,2,3,4&#125;, &#123;2,3,4,5&#125;, &#123;3,4,5,6&#125;, &#123;4,5,6,7&#125;&#125;; 从技术上来看 这是一个一维的int[]数组，要访问元素，使用两个中括号。123int element = square[1][2];//第一个索引选择行数组square[1]//第二个索引从该行数组获得元素 可以互相换行123int[] temp = square[0];square[0]=square[1];square[1]=temp; 如果你不提供初始值，则必须使用new操作符并指定行数和列数1int[][] square =new int[4][4];//行在前列在后。 二维数组的实际实现就是，数组的每一行是用数组填充的。并不要求数组的每一行长度相同。 遍历二位数组需要使用两个循环，一个行循环，一个列循环。 对于二维数组，有方法Arrays.deepToString(array). 没有二维的数组列表，但是可以声明ArrayList&lt;ArrayList&gt;类型的变量并自己构建行。 1.9 功能分解如果你的main方法太长了，则可以将程序分解到多个类中。对于一个简单的程序，可以将程序代码分解到同一个类的方法中。这些方法都必须以static修饰符声明，如同main一样。本书的第二章会介绍。 静态方法的声明与调用声明方法时，在方法头提供返回值类型、方法名称以及参数名称。然后在方法体提供方法的实现。return返回结果。 例如如下的例子：12345678910111213public static double average(double x,double y)&#123; double sum = x + y; return sum/2;&#125;//该方法与main在同一个类中，可以直接调用//java中与出现的前后顺序没有关系public static void main(String[] args)&#123; double a = ...; double b = ...; double average = average(a,b); ...&#125; 数组参数与返回值可以将数组传递给方法，方法只是收到数组的引用，通过引用可以修改原数组。 例如下面这个例子交换数组的两个元素123456public static void swap(int[] values,int i,int j)&#123; int temp = values[i]; values[i] = values[j]; values[j] = temp&#125;//此方法直接对数组进行修改 不需要返回值 方法可以返回数组。下面这个方法返回一个数组，返回的数组是生产的一个新数组。 1234public static int[] firstLast(int[] values)&#123; if (values.length == 0) return new int[0]; else return new int[]&#123;values[0],values[values.length-1]&#125;&#125; 可变参数如printf这样的方法，允许调用者提供数量可变的参数例如123System.out.printf(\"%d\", n);//与System.out.printf(\"%d %s\",n,\"Hello\"); 虽然他们调用同样的方法，但是参数个数不同。 我们定义一个average方法，在类型之后加上...声明变长参数，这样我们就可以以任意参数长度调用average。1public static double average(double... values) 参数实际上是double类型的数组。当方法被调用时，创建了一个数组并且以参数填充该数组。在方法体中，可以像数组一样使用。12345public static double average(double... values)&#123; double sum = 0; for (double v : values) sum += v; return values.length == 0 ? 0 :sum / values.length;&#125; 注意 可变参数必须是方法的最后一个参数，例如1public static double max(double first,double... rest)","tags":[{"name":"《Java核心技术》","slug":"《Java核心技术》","permalink":"https://minoyu.github.io/tags/《Java核心技术》/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://minoyu.github.io/tags/学习笔记/"}]},{"title":"Core Java Day4--基本编程结构4(输入与输出、控制流)","date":"2018-10-25T08:48:12.000Z","path":"2018/10/25/Core-Java-Day4-基本编程结构4/","text":"1.6输入与输出读取输入调用System.out.println时，输出发送到“标准输出流”，然后在窗口上显示出来。 但从“标准输入流”读取不是那么简单，因为相应的System.in对象只有读取单个字节的方法。要想读取字符串和数字，需要构造一个Scanner对象依附到System.in Scanner类位于java.util包中，使用前要在程序的开始位置import. 123456789101112131415161718192021222324import java.util.Scanner;Scanner in = new Scanner(System.in);//nextLine方法从输入读取一行System.out.println(\"What's your name?\");String name = in.nextLine();//这里nextLine是合理的，因为名字可能会有姓名分割。//如果要读取用空格分割的单个单词，使用nextString firstName = in.next();//整数和浮点数 可以使用String age = in.nextInt();String score = in.nextDouble();//还有一些判断方法in.hasNextLine();in.hasNext();in.hasNextInt();in.hasNextDouble();//可以在读取前判断一下，例如if(in.hasNextInt())&#123; int age = in.nextInt();&#125; 在终端读取密码读取密码时可以使用Console类来代替因为Scanner是可见的。123Console terminal = System.console();String username = terminal.readLIne(\"User name: \");char[] passwd = terminal.readPassword(\"Password:\") 密码以一组字符串数组的形式返回。与将密码存在字符串中相比更加的安全，因为在完成必要的工作后，数组可以重写而字符串不能更改。 格式化输出 println新起一行，所有数字都会显示 print不会新起一行，所有数字都会显示 printf格式输出方法12345System.out.print(1000.0/3.0);//333.333333333333System.out.printf(\"%8.2f\",1000.0/3.0);//浮点数宽度为８（包括小数点），精度为小数点后两位//□□333.33 以%开头的每一个格式说明符都会被相应的参数替代，转换字符说明了要被格式化的值所属的类型 printf的使用方法和Ｃ很相似。1System.out.printf(\"%s,%d\",name,age) 格式化输出的转换字符 此外，还可以指定一些标记符控制格式化输出的显示形式 格式化输出的标记符 例如，为一个浮点数添加分组标记符和正负标记符12System.out.printf(\"%f\",100000.0/3.0);//+33,333.33 你也可以使用String.format方法来创建不打印输出的格式化字符串 1String message = String.format(\"%s,%d\",name,age) 1.7控制流Java的控制流声明与其他语言非常的相似，这里我可能会略过一些相似的内容。 分支像if/else/switch等的分支结构我们已经非常熟悉 需要注意的是不要忘记在想要结束的分支末尾添加break. 在java中，case可以使用以下任何类型的类型值 char,byte,short或int类型的常量表达式(或者这些类型的包装类) 文字串 枚举类型值（第四章） 循环while/do while/for 在for语句中如果省略了条件，则默认为总是真。12for(;;)//无限循环 Java中有一种增强的for循环，使针对数组或集合的for循环的写法更加方便，之后将在数组中讲到。 跳出循环和继续循环 break 退出循环 continue 跳到下一次循环 可以在应该退出的声明前加上标签，为break提供标签，例如：1234567891011outer:while()&#123; ... while()&#123; ... if(...) break outer; ... &#125; ...&#125;//带标签的break跳转到这里 注意：你在声明的顶部加标签，但是break声明跳到尾部。普通的break只能用来退出循环或switch，但是带标签的break可以将控制转移到任何声明的结束，甚至是一个声明块。123456exit:&#123; ... if(...) break exit; ...&#125;//带标签的break跳转到这里 continue声明也可以带标签，它可以跳转到标签循环的下一个迭代。 !!!过多的break和continue会让程序变得难以阅读，晕头转向，你完全可以选择没有他们的编程方式","tags":[{"name":"《Java核心技术》","slug":"《Java核心技术》","permalink":"https://minoyu.github.io/tags/《Java核心技术》/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://minoyu.github.io/tags/学习笔记/"}]},{"title":"Core Java Day 3--基本编程结构3(操作运算、字符串)","date":"2018-10-22T15:06:11.000Z","path":"2018/10/22/Core-Java-Day-3-基本编程结构-3/","text":"1.4 操作运算Java 与基于Ｃ语言的所有语言使用相似的操作符，接下来我来找一些在java需要注意的地方。 基本运算 要格外小心/操作符，如果两个操作数都是整数，它代表整数。如果有一个操作数为小数则输出结果为浮点型。（类型的自动转换）。 整数除以０会导致异常，浮点数除以０会产生无限值或NaN,不会产生异常。 若ｎ为奇数，当ｎ为正数时，n%2 的值为１； 当ｎ为负数时，n%2的值为－１。实际中处理负数是不幸的。当操作数可能为负数时，切记小心使用％。可以考虑使用Math.floorMod方法。 数学方法举个例子，没有操作符可以产生次方，但是你可以调用Math.pow方法，Math.pow(x,y)会产生ｘ的ｙ次方。 静态方法不用在对象上调用。像静态常量一样，你只需要在前面加上声明该静态方法/变量的类名 类似的方法还有Math.sqrt/Math.min/Math.max等 此外Math类中提供三角函数和对数方法，以及常量Math.PI和Math.E。 Math类中提供一些可以让整数运算更安全的方法，你可以捕获异常或终止程序，而不会是像普通的数学运算符那样使程序以错误的结果默默继续运行。 数字类型的转换在Java中，如果没有信息损失，转换总是合法的。 从byte类型 到 short、int、long或double 从short和char类型 到 int、long或double 从int类型到long、double 从整型到浮点型总是合法的 ==需要注意的是 下面的转换是合法的，但是他们损失了信息== 从int到float 从long到float或double。 如果转换不允许，可以使用cast运算符（将目标类型写在括号中）来强制转换，例如： 123double x = 3.75;int n =(int)x;//这种情况下，就丢弃了小数部分，将ｎh设置为了3. 如果你想获得四舍五入后的整数而不是直接丢弃小数，你可以使用Math.round(x)。 ==当使用cast方式强制转换数据时，需要格外注意。==如果你收到了警告，cast转换会悄悄地丢弃掉数字的部分数据，你可以使用Math.toIntExact方法代替，当无法转换时会抛出异常。 大数如果基本的整数类型和浮点类型精确度还不够满足需求，你可以使用java.math包中的BigInteger和BigDecimal类。这些类的对象代表了数字，该数字有任意长序列的位数。他们实现了对任意精度整数/浮点数的计算。 BigInteger类的静态方法valueOf讲long型转换为BigInteger1BigInteger n = BigInteger.valueOf(124135431242L); 你也可以使用数字字符串构造BigInteger:1BigInteger m = new BigInteger(\"124135431242\"); Java不允许对象使用操作符，因此操作大数时，必须使用方法调用。例如12BigInteger o = BigInteger.valueOf(5).multiply(n.add(m))//5*(n+m) 记得在之前我们遇到的,使用浮点类型2.0-1.1的结果为0.99999999…吗,在这里我们使用BigDecimal可以计算出准确结果。BigDecimal.valueOf(n,e) 返回BigDecimal实例，其值为ｎ×10的-e次方12BigDecimal.valueOf(2,0).substract(BigDecimal.valueOf(11,1))//2.0-1.1 输出的结果精确为0.9 字符串字符串就是一系列的字符，在java中，字符串可以包含任何Unicode字符。 字符串连接可以使用操作符＋连接两个字符串如果将一个字符串和另一个值连接起来，另一个值会转换为字符串。 ==注意 如果将连接与加写在一起，可能会有意想不到的结果==例如：1234int age =20;\"your age :\" + age + 1;//结果为 your age : 201//正确为\"your age :\" + （age + 1）; 也可以使用String类下的join方法讲几个字符串连接起来并以分割符隔开123String names = String.join(\",\",\"Mino\",\"Peter\",\"Paul\");//names的结果为“Mino,Peter,Paul“//或者第二个参数提供字符串数组 如果有大量字符串需要连接，那么上面这种方式是效率低下的，最好使用StringBuilder代替12345StringBuilder builder = new StringBuilder();while(isMoreString)&#123; builder.append(nextString);&#125;String result = builder.toString(); 子字符串（字符串拆分）可以使用substring方法将字符串拆开123String greeting = \"Hello world\";String location = greeting.substring(7,12);//设置location为\"world\"(起位置７ 结束位置12,字符串的位置从０开始) 你也可以用split()方法将含有分隔符分割的字符串提取出子字符串，返回一个子字符串数组。123String names = \"Peter,Mino,Mary\";String[] result = names.split(\",\");//返回的结果值为数组[\"Peter\",\"Mino\",\"Mary\"] 字符串比较12location.equals(\"world\");//若location是字符串”world“,返回真 ==不要使用==操作符来比较字符串，只有当两者在内存中为同一对象时，返回真，（可以看成地址的比较）。在Java虚拟机中，每个文字串只有一个实例，所以”world“==“world”为真，但是如果字符串是计算得来的，那么变量中的字符串会单独存放到一个实例中，此时虽然他们的值相等，但==返回值为假== 例如：123456\"world\"==\"world\";//返回trueString greeting = \"Hello world\";String location = greeting.substring(7,12);location == \"world\";//返回false 与其他任何变量一样，String变量可以是null，这表明该变量根本没有引用任何对象，甚至不是一个空字符串。 null与空字符串&quot;&quot;并不相同。空字符串是个长度为零的字符串，而null根本不是字符串。在null上调用任何方法都会抛出空指针异常。 可以使用==来测试一个字符串是否为null.if(location == null)... 比较字符串和文字串时，将文字串放在前面会是一个好主意，英文即使字符串为null，这个语句也可以正常工作1if(\"world\".equals(location)) ... equalsIgnoreCase方法不考虑大小写的比较两个字符串 compareTo方法可以告诉你两个字符串按照字典中的顺序（依赖于Unicode值）哪个在前。1first.compareTo(second) 返回值&lt;0(负整数)，first排前 返回值=0 ,两者相等 返回值&gt;0(正整数),second排前 对用户可读的字符串排序时，推荐使用Collator对象（它知道关于特定语言的排序规则）。 数字与字符串转换整数转换为字符串 可调用静态方法 Integer.toString(num);可以传入第二个参数作为转换的进制（2~36）Integer.toString(num , 2); 则返回为num转换为２进制之后的结果 将整数转换为字符串的更简单的办法是&quot;&quot;+num.但是有些人认为这种方式比较丑陋并且效率低下。 相反 将整数的字符串转为数字，使用Integer.parseInt方法。1234n = Integer.parseInt(\"11\");//也可以指定进制数m = Integer.parseInt(\"11\",2);//ｍ的值为整数３ 对于浮点数，也有对应的Double.toString和Double.parseDouble方法。 String类API有用的String类方法 有用的String类方法 注意，在Java 中 String 类是不可变的(immutable)．也就是说任何String类的方法都不能修改自己的字符串。返回的是一个新的字符串，源字符串不会改变。 == 可以在网上下载详细的JavaAPI文档，里面有各个API的详解 == 编码点和编码单元Java开始创建时，拥抱了刚出来不久的Unicode标准，目的是解决棘手的字符编码的问题在Unicode之前，有很多不兼容的字符编码方式，每个国家都在做类似的事情，拓展ASCII标准来容纳各自的语言符号，不同编码文件之间的交流成为了一个大问题。 现在，Unicode需要21个bit，而不是设计之初的16bit(因为引入了比实际时估计更多的字符而扩容)。每个有效的Unicode值被称为编码点(code point). Java 诞生在16bit向21bit过度的时期，深受其苦。在Java中，字符串不是Unicode字符或者编码点的序列，而是编码单元(code unit),UTF-16编码的１６比特序列. 编码点和编码单元的一些方法","tags":[{"name":"《Java核心技术》","slug":"《Java核心技术》","permalink":"https://minoyu.github.io/tags/《Java核心技术》/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://minoyu.github.io/tags/学习笔记/"}]},{"title":"Core Java Day 2--基本编程结构2(基本类型、变量)","date":"2018-10-19T11:50:07.000Z","path":"2018/10/19/Core-Java-Day-2-基本编程结构-2/","text":"1.2 基本类型接下来我们来看一下Java中7的基本类型。最简单的Java类型被称为基本类型，这些与C/C++基本类似，详细的我就不在这里介绍了，主要找一些需要注意的地方吧 1.2.1 整型整型是没有小数部分的数字，java中有四种整型 java中的四种整型 我们可以通过这些类的.MIN_VALUE,.MAX_VALUE常量获取到其可取到的最大值和最小值 如果long类型还不够用，则使用BigInteger类 与C/C++不同的是，Java中的整型范围不依赖程序所运行的机器。”编写一次 到处运行”; 在java中你还可以给数字添加下划线 ，使阅读变得更加容易，Java编译器会删除他们。例如1_000_000。 1.2.2 浮点类型浮点类型是指有分数的数字 浮点类型 float类有个F后缀（例如 3.14F）。没有F后缀的浮点类型被默认为Double 你可以选择D作为double类型的后缀（例如3.14D） 有一个特殊的浮点值 Double.POSITIVE_INFINITY 代表正无穷 Double.NEGATIVE_INFINITY 代表负无穷。例如，1.0/0.0结果就是无穷大。3.Double.NaN代表非数值， 0例如，.0/0.0或者负数的平方根就会产生无数值NaN。 需要注意的是，所有的NaN 都被认为是彼此不同的所以不能用简单的if(x == NaN)来检查x是否是NaN。但是，你可以使用Double.isNaN(x)来判断。同样 你还可以使用Double.isInfinite来测试是否为正负无穷大 用方法Double.isFinite可以检查浮点数既不是无穷也不是NaN 有时浮点数会存在一些舍入误差，并不适用于对精度要求特别高的地方 例如命令 System.out.println(2.0-1.1)的打印结果为0.899999999999999… 而非我们所期望的0.9 这样的原因是浮点数使用了二进制系统进行表示。分数十分之一没法用精确的二进制表示。就好像分时三分之一在十进制下无法精确表示一样。如果你需要精确而无舍入误差的数字计算 你可以使用BigDecimal类 1.2.3 char 型 char类型 你可能不会经常使用char型，char型描述了Java使用的UTF-16字符编码中的“编码单元”; 1.2.4 布尔型布尔型有两种值 true 和 false 但值得注意的是 在java中布尔类型不是数字类型。布尔值与整数0和1没有关系 1.3 变量关于如何声明与初始化变量与常量 1.3.1变量的声明Java是强类型语言。变量值只能是某个具体类型的值。当你声明变量时，需要指定变量的类型、名称和一个可选的初始值。 如：1int total = 0; 这部分基本与C/C++类似 &quot;大多数Java程序员喜欢每个变量有各自单独的声明&quot; 当你声明变量并用构造对象初始化变量时，对象所属类的名称会出现两次：如12Random generator = new Random();//第一个变量Random 是变量generator的类型。第二个Random是构造该类对象的表达式的一部分。 1.3.2 关于变量的名称允许的变量名格式与C、C++基本类似 根据习惯 变量和方法的名称以小写字母开始，类的名称的第一个字母大写。 Java程序员喜欢使用&quot;驼峰式大小写&quot;，也就是当名称由多个单词组成时，单词首字母大写，例如countOfNums。 1.3.3 初始化 和C、C++相同，你必须再使用变量前对声明的变量进行初始化 允许在方法的任何地方声明变量，但尽可能晚地声明变量，刚好在你首次需要变量的前一刻声明，被认为是一种好习惯。 1.3.4 常量关键词final表示一个值，一旦赋值后就不能改变了。1final int DAYS_PER_WEEK = 7; 根据习惯，常量的名称使用大写字母。 你也可以在方法外，使用static关键词声明常量。例如：123public class Calendar &#123; public static final int DAYS_PER_WEEK = 7;&#125; 常量可以用在多个方法中。在Calendar类内部，你可以直接引用常量DAYS_PER_WEEK。而要在其他的类中使用常量，前面要加上类名：Calendar.DAYS_PER_WEEK。 例如我们常用的输出对象 System类中声明了一个out常量1public static final PrintStream out; 于是 你就可以在任何地方愉快的使用System.out对象了。貌似这是极少数几个常量没有大写的情况 延迟final变量的初始化是允许的，只要确保它在使用之前恰好初始化了一次即可，例如： 1234567final int DAYS_IN_FEBRUARY;if(oleapYear)&#123; DAYS_IN_FEBRUARY =29;&#125;else&#123; DAYS_IN_FEBRUARY = 28;&#125; final变量 一旦被赋值 它就是最终的值，且无法被改变。 如果你需要定义一组相关的常量，这时你可以定义枚举类型了。 枚举类型","tags":[{"name":"《Java核心技术》","slug":"《Java核心技术》","permalink":"https://minoyu.github.io/tags/《Java核心技术》/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://minoyu.github.io/tags/学习笔记/"}]},{"title":"Core Java Day 1--基本编程结构1(Hello World)","date":"2018-10-19T09:02:06.000Z","path":"2018/10/19/Core-Java-Day-1-基本编程结构-1/","text":"关于这个笔记最近开始想系统性的啃一啃Java，觉得以前自己学的都太乱太杂，反而学艺不精。现在准备开始照着《Java核心技术》开始怼下去，希望自己可以坚持下去吧，这次不弃坑不弃坑 T.T 1.基本编程结构一些要点 Java中所有的方法必须在类中声明。非静态方法只能在该方法所属类的对象上调用 静态方法不是通过对象调用。程序从静态的main方法开始执行 Java有8个基本数据类型： 5个整型 2个浮点型和1个布尔型 Java操作符和控制结构与C/Javascript非常相似 Math类提供常见的数学函数 字符串对象是字符序列，或者更精确的说 是UTF-16编码中Unicode编码点的序列 Java中使用System.out对象 可在终端窗口显示输出 绑定System.in的Scanner可以读取终端输入 数组和集合用来收集相同类型的元素 1.1 Hello World 一个简单的Hello World程序 一些解析 Java是面向对象的一门语言，绝大多数情况下通过操作_对象_来进行工作。对象属于某个类，类定义了对象能做什么。在Java中，所有的代码都必须在类中定义好。例如在这个HelloWorld程序由一个HelloWorld类组成。 main是方法，也就是在类中声明的函数。main方法是程序运行时调用的第一个方法。它被声明为静态static，表示该方法不是依赖于对象运行的。方法声明为void，指出该方法不会有返回值。 在Java中可以声明一些特性（可见性） 例如public或private package（包） 是一组相关类的集合。每个类都放入一个包中，这样就可以区分相同类名的多个类。 回到main方法的方法体中 它由一行语句组成，作用是讲消息打印到讲讲System.out对象 该对象在Java中代表标准输出 所以，Java被明确定义为可以从组织有序的类和包中获益的大型程序的编程语言 在Java中 所有的一切都必须在类中声明相当简单和一致 1.1.2 Java程序的编译与运行安装好JDK之后，我们可以运行用终端打开，输入以下的命令，以刚才的Hello World为例 12345$ javac ch01/sec01/HelloWorld.java//javac命令将java源代码编译为中间代码，也称为字节码，并将他们保存到类文件中。$ java ch01.sec01.HelloWorld//Java 命令启动虚拟机，虚拟机加载类文件并执行字节码。 所以，一旦编译完成，字节码可以在任何Java虚拟机上运行 &quot; 编写一次，到处运行 &quot; 1.1.3 方法调用1System.out.println(\"Hello World!\"); System.out是对象。这是PrintStream类的实例。PrintStream类有println、print等方法。 类似这样的方法被称为实例方法，他们运行在对象，或者类的实例上。 调用对象上的实例方法使用点符号1object.methodName(arguments) 另一个例子1\"Hello world\".length(); 此处的 “Hello world” 是String类的实例，String 有一个length方法 用于返回字符串对象的长度。 在Java中 你需要构造绝大多数的对象（而不是像此处的System.out和”Hello World”对象直接使用就好，因为他们已经存在） 1new 类名 ( 构造函数的参数列表 ); 举个例子Random类的对象可以产生随机数，你可以使用new操作符构建一个Random对象1new Random(); 此处的构造函数参数为空 你可以直接在构造对象上调用方法，例如 1new Random().nextInt(); 新构造的随机数产生器会提供一个整数 如果想要在一个对象上调用多个方法，可以先将该对象用变量存下来，例如接下来我们打印两个随机数： 12345Random generator = new Random();System.out.println(generator.nextInt());System.out.println(generator.nextInt()); 注意 Random类声明在java.util包中。要在程序中使用该类，需要添加import声明，如： 1import java.util.Random;","tags":[{"name":"《Java核心技术》","slug":"《Java核心技术》","permalink":"https://minoyu.github.io/tags/《Java核心技术》/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://minoyu.github.io/tags/学习笔记/"}]},{"title":"Hello World! My first hexo post! (hexo的常用命令及优化)","date":"2018-10-18T09:02:06.000Z","path":"2018/10/18/hello-world/","text":"关于这里哈哈哈，第一次尝试用Hexo来搭建一个博客，放在github page上，尝试了一下。以后这里主要用来记录我的学习笔记和一些探索总结吧。 话说觉得Hexo真的好神奇，脱离了数据库，用一个个md文档充当文章的内容，在本地写好md文档后编译成Html,再推上服务器。实现了纯静态的访问，蛮有意思的XD 那就这样吧，接下来开始我的记录咯。1$ hexo new \"My First Note！\" 个人博客: 我们的小确幸 hexo的常用命令12345678# 新建文章$ hexo new [layout] &lt;title&gt;# 生成静态文件$ hexo g# 部署网站$ hexo d# 清除缓存文件 (db.json) 和已生成的静态文件 (public)。$ hexo clean hexo的优化虽然hexo已经很优秀了，但考虑到毕竟是放在github page上的，还是稍微做一些优化。 静态资源优化主要是压缩html,css,js等等静态资源，可以适当减少请求的数据量，主要用到gulp来实现。 安装gulp 1234# 全局安装gulp工具 以yarn工具为例$ yarn global add gulp-cli# 给项目安装各种gulp插件 分别负责压缩html 图片 css js$ yarn add gulp gulp-htmlclean gulp-htmlmin gulp-imagemin gulp-minify-css gulp-uglify 配置文件 在根目录下添加gulpfile.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657var gulp = require('gulp');var minifycss = require('gulp-minify-css');var uglify = require('gulp-uglify');var htmlmin = require('gulp-htmlmin');var htmlclean = require('gulp-htmlclean');var imagemin = require('gulp-imagemin');// 压缩htmlgulp.task('minify-html', function() &#123; return gulp.src('./public/**/*.html') .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest('./public'))&#125;);// 压缩cssgulp.task('minify-css', function() &#123; return gulp.src('./public/**/*.css') .pipe(minifycss(&#123; compatibility: 'ie8' &#125;)) .pipe(gulp.dest('./public'));&#125;);// 压缩jsgulp.task('minify-js', function() &#123; return gulp.src('./public/js/**/*.js') .pipe(uglify()) .pipe(gulp.dest('./public'));&#125;);// 压缩图片gulp.task('minify-images', function() &#123; return gulp.src('./public/img/**/*.*') .pipe(imagemin( [imagemin.gifsicle(&#123;'optimizationLevel': 3&#125;), imagemin.jpegtran(&#123;'progressive': true&#125;), imagemin.optipng(&#123;'optimizationLevel': 7&#125;), imagemin.svgo()], &#123;'verbose': true&#125;)) .pipe(gulp.dest('./public/img'))&#125;);//4.0以前的写法 //gulp.task('default', [ // 'minify-html', 'minify-css', 'minify-js'，'minify-images'//]);// 默认任务 gulp4以上写法 gulp.parallel 任务同时进行gulp.task('default', gulp.parallel( 'minify-html', 'minify-css', 'minify-js', 'minify-images')); 在hexo g生成文件后运行gulp123$ hexo g$ gulp$ hexo d 生成sitemap文件生成sitemap文件然后提交给搜索引擎，对于SEO很有帮助，hexo有相关的sitemap插件。 安装这俩插件后，以后每次hexo g都会生成sitemap.xml和baidusitemap.xml文件并自动帮你放到public目录。 1$ yarn add hexo-generator-sitemap hexo-generator-baidu-sitemap","tags":[{"name":"杂类","slug":"杂类","permalink":"https://minoyu.github.io/tags/杂类/"},{"name":"Hello world","slug":"Hello-world","permalink":"https://minoyu.github.io/tags/Hello-world/"}]}]