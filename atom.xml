<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小余有个大梦想</title>
  <icon>https://www.gravatar.com/avatar/a291781eeb8444a1250c980a03013d59</icon>
  <subtitle>我的学习笔记</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://minoyu.github.io/"/>
  <updated>2019-01-25T14:18:24.106Z</updated>
  <id>https://minoyu.github.io/</id>
  
  <author>
    <name>Minoyu</name>
    <email>yu-letao@outlook.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>我的JavaScript简略笔记04(标准库)</title>
    <link href="https://minoyu.github.io/2019/01/25/%E6%88%91%E7%9A%84JavaScript%E7%AE%80%E7%95%A5%E7%AC%94%E8%AE%B004/"/>
    <id>https://minoyu.github.io/2019/01/25/我的JavaScript简略笔记04/</id>
    <published>2019-01-25T10:10:51.000Z</published>
    <updated>2019-01-25T14:18:24.106Z</updated>
    
    <content type="html"><![CDATA[<h1 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h1><h2 id="Object对象"><a href="#Object对象" class="headerlink" title="Object对象"></a>Object对象</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>JavaScript 的所有其他对象都继承自Object对象，即那些对象都是Object的实例。<br>Object对象的原生方法分成两类：Object本身的方法与Object的实例方法。</p><h4 id="Object对象本身的方法"><a href="#Object对象本身的方法" class="headerlink" title="Object对象本身的方法"></a>Object对象本身的方法</h4><p>所谓“本身的方法”就是直接定义在Object对象的方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.print = <span class="function"><span class="keyword">function</span> (<span class="params">o</span>) </span>&#123; <span class="built_in">console</span>.log(o) &#125;;</span><br></pre></td></tr></table></figure></p><h4 id="Object的实例方法"><a href="#Object的实例方法" class="headerlink" title="Object的实例方法"></a>Object的实例方法</h4><p>所谓实例方法就是定义在Object原型对象Object.prototype上的方法。它可以被Object实例直接使用。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.print = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">obj.print() <span class="comment">// Object</span></span><br></pre></td></tr></table></figure></p><h3 id="Object"><a href="#Object" class="headerlink" title="Object()"></a>Object()</h3><p>Object本身是一个函数，可以当作工具方法使用，将任意值转为对象。这个方法常用于保证某个值一定是对象。</p><blockquote><p>PS. <code>instanceof</code> 运算符用来验证，一个对象是否为指定的构造函数的实例。</p></blockquote><p>如果参数是原始类型的值，Object方法将其转为对应的包装对象的实例（参见《原始类型的包装对象》一章）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>(<span class="number">1</span>);</span><br><span class="line">obj <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line">obj <span class="keyword">instanceof</span> <span class="built_in">Number</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>(<span class="string">'foo'</span>);</span><br><span class="line">obj <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line">obj <span class="keyword">instanceof</span> <span class="built_in">String</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>(<span class="literal">true</span>);</span><br><span class="line">obj <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line">obj <span class="keyword">instanceof</span> <span class="built_in">Boolean</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果Object方法的参数是一个对象，它总是返回该对象，即不用转换。</p><h3 id="Object-构造函数"><a href="#Object-构造函数" class="headerlink" title="Object 构造函数"></a>Object 构造函数</h3><p>Object不仅可以当作工具函数使用，还可以当作构造函数使用，即前面可以使用new命令。</p><p>Object构造函数的首要用途，是直接通过它来生成新对象。</p><blockquote><p>注意，通过<code>var obj = new Object()</code>的写法生成新对象，与字面量的写法<code>var obj = {}</code>是等价的。或者说，后者只是前者的一种简便写法。<br>Object构造函数的用法与工具方法很相似，几乎一模一样。使用时，可以接受一个参数，如果该参数是一个对象，则直接返回这个对象；如果是一个原始类型的值，则返回该值对应的包装对象（详见《包装对象》一章）。</p></blockquote><h3 id="Object-的静态方法"><a href="#Object-的静态方法" class="headerlink" title="Object 的静态方法"></a>Object 的静态方法</h3><p>所谓“静态方法”，是指部署在Object对象自身的方法。</p><h4 id="Object-keys-，Object-getOwnPropertyNames"><a href="#Object-keys-，Object-getOwnPropertyNames" class="headerlink" title="Object.keys()，Object.getOwnPropertyNames()"></a>Object.keys()，Object.getOwnPropertyNames()</h4><p><code>Object.keys</code>方法和<code>Object.getOwnPropertyNames</code>方法都用来遍历对象的属性。</p><p>对于一般的对象来说，Object.keys()和Object.getOwnPropertyNames()返回的结果是一样的。只有涉及不可枚举属性时，才会有不一样的结果。Object.keys方法只返回可枚举的属性（详见《对象属性的描述对象》一章），Object.getOwnPropertyNames方法还返回不可枚举的属性名。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">'Hello'</span>, <span class="string">'World'</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(a) <span class="comment">// ["0", "1"]</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(a) <span class="comment">// ["0", "1", "length"]</span></span><br></pre></td></tr></table></figure></p><p>上面代码中，数组的length属性是不可枚举的属性，所以只出现在Object.getOwnPropertyNames方法的返回结果中。</p><h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><p>除了上面提到的两个方法，Object还有不少其他静态方法，将在后文逐一详细介绍。</p><h5 id="对象属性模型的相关方法"><a href="#对象属性模型的相关方法" class="headerlink" title="对象属性模型的相关方法"></a>对象属性模型的相关方法</h5><ul><li>Object.getOwnPropertyDescriptor()：获取某个属性的描述对象。</li><li>Object.defineProperty()：通过描述对象，定义某个属性。</li><li>Object.defineProperties()：通过描述对象，定义多个属性。</li></ul><h5 id="控制对象状态的方法"><a href="#控制对象状态的方法" class="headerlink" title="控制对象状态的方法"></a>控制对象状态的方法</h5><ul><li>Object.preventExtensions()：防止对象扩展。</li><li>Object.isExtensible()：判断对象是否可扩展。</li><li>Object.seal()：禁止对象配置。</li><li>Object.isSealed()：判断一个对象是否可配置。</li><li>Object.freeze()：冻结一个对象。</li><li>Object.isFrozen()：判断一个对象是否被冻结。</li></ul><h5 id="原型链相关方法"><a href="#原型链相关方法" class="headerlink" title="原型链相关方法"></a>原型链相关方法</h5><ul><li>Object.create()：该方法可以指定原型对象和属性，返回一个新的对象。</li><li>Object.getPrototypeOf()：获取对象的Prototype对象。<h3 id="Object-的实例方法"><a href="#Object-的实例方法" class="headerlink" title="Object 的实例方法"></a>Object 的实例方法</h3>除了静态方法，还有不少方法定义在Object.prototype对象。它们称为实例方法，所有Object的实例对象都继承了这些方法。</li></ul><p>Object实例对象的方法，主要有以下六个。</p><ul><li>Object.prototype.valueOf()：返回当前对象对应的值。</li><li>Object.prototype.toString()：返回当前对象对应的字符串形式。</li><li>Object.prototype.toLocaleString()：返回当前对象对应的本地字符串形式。</li><li>Object.prototype.hasOwnProperty()：判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性。</li><li>Object.prototype.isPrototypeOf()：判断当前对象是否为另一个对象的原型。</li><li>Object.prototype.propertyIsEnumerable()：判断某个属性是否可枚举。</li></ul><h4 id="Object-prototype-valueOf"><a href="#Object-prototype-valueOf" class="headerlink" title="Object.prototype.valueOf()"></a>Object.prototype.valueOf()</h4><p>valueOf方法的作用是返回一个对象的“值”，默认情况下返回对象本身。</p><p>valueOf方法的主要用途是，JavaScript 自动类型转换时会默认调用这个方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="number">1</span> + obj <span class="comment">// "1[object Object]"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">obj.valueOf = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> + obj <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p><p>上面代码将对象obj与数字1相加，这时 JavaScript 就会默认调用valueOf()方法，求出obj的值再与1相加。所以，如果自定义valueOf方法，就可以得到想要的结果。</p><h4 id="Object-prototype-toString"><a href="#Object-prototype-toString" class="headerlink" title="Object.prototype.toString()"></a>Object.prototype.toString()</h4><p>toString方法的作用是返回一个对象的字符串形式，默认情况下返回类型字符串。对于一个对象调用toString方法，会返回字符串[object Object]，该字符串说明对象的类型。</p><p>字符串[object Object]本身没有太大的用处，但是通过自定义toString方法，可以让对象在自动类型转换时，得到想要的字符串形式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line">obj.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'hello'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj + <span class="string">' '</span> + <span class="string">'world'</span> <span class="comment">// "hello world"</span></span><br></pre></td></tr></table></figure><p>数组、字符串、函数、Date 对象都分别部署了自定义的toString方法，覆盖了Object.prototype.toString方法。</p><h5 id="toString-的应用：判断数据类型"><a href="#toString-的应用：判断数据类型" class="headerlink" title="toString() 的应用：判断数据类型"></a>toString() 的应用：判断数据类型</h5><p>由于实例对象可能会自定义toString方法，覆盖掉Object.prototype.toString方法，所以为了得到类型字符串，最好直接使用Object.prototype.toString方法。通过函数的call方法，可以在任意值上调用这个方法，帮助我们判断这个值的类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(value)</span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="number">2</span>) <span class="comment">// "[object Number]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">''</span>) <span class="comment">// "[object String]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">true</span>) <span class="comment">// "[object Boolean]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>) <span class="comment">// "[object Undefined]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>) <span class="comment">// "[object Null]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">Math</span>) <span class="comment">// "[object Math]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(&#123;&#125;) <span class="comment">// "[object Object]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call([]) <span class="comment">// "[object Array]"</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;标准库&quot;&gt;&lt;a href=&quot;#标准库&quot; class=&quot;headerlink&quot; title=&quot;标准库&quot;&gt;&lt;/a&gt;标准库&lt;/h1&gt;&lt;h2 id=&quot;Object对象&quot;&gt;&lt;a href=&quot;#Object对象&quot; class=&quot;headerlink&quot; title=&quot;Objec
      
    
    </summary>
    
      <category term="学习笔记" scheme="https://minoyu.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JavaScript" scheme="https://minoyu.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JavaScript/"/>
    
    
      <category term="《JavaScript 标准参考教程-阮一峰》" scheme="https://minoyu.github.io/tags/%E3%80%8AJavaScript-%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B-%E9%98%AE%E4%B8%80%E5%B3%B0%E3%80%8B/"/>
    
      <category term="学习笔记" scheme="https://minoyu.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>我的JavaScript简略学习笔记03(语法专题)</title>
    <link href="https://minoyu.github.io/2019/01/24/%E6%88%91%E7%9A%84JavaScript%E7%AE%80%E7%95%A5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B003/"/>
    <id>https://minoyu.github.io/2019/01/24/我的JavaScript简略学习笔记03/</id>
    <published>2019-01-24T13:07:27.000Z</published>
    <updated>2019-01-25T08:16:29.488Z</updated>
    
    <content type="html"><![CDATA[<h1 id="语法专题"><a href="#语法专题" class="headerlink" title="语法专题"></a>语法专题</h1><h2 id="数据类型的转换"><a href="#数据类型的转换" class="headerlink" title="数据类型的转换"></a>数据类型的转换</h2><p>JavaScript 是一种动态类型语言，变量没有类型限制，可以随时赋予任意值。</p><p>虽然变量的数据类型是不确定的，但是各种运算符对数据类型是有要求的。如果运算符发现，运算子的类型与预期不符，就会自动转换类型。</p><h3 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h3><p>强制转换主要指使用Number()、String()和Boolean()三个函数，手动将各种类型的值，分别转换成数字、字符串或者布尔值。</p><h4 id="Number"><a href="#Number" class="headerlink" title="Number()"></a>Number()</h4><h5 id="对原始类型值"><a href="#对原始类型值" class="headerlink" title="对原始类型值"></a>对原始类型值</h5><ol><li>字符串：如果不可以被解析为数值，返回 NaN</li><li>空字符串转为0</li><li>布尔值：true 转成 1，false 转成 0</li><li>undefined：转成 NaN</li><li>null：转成0</li></ol><p>Number函数将字符串转为数值，要比parseInt函数严格很多。基本上，只要有一个字符无法转成数值，整个字符串就会被转为NaN。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'42 cats'</span>) <span class="comment">// 42</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">'42 cats'</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure></p><p>另外，parseInt和Number函数都会自动过滤一个字符串前导和后缀的空格。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'\t\v\r12.34\n'</span>) <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">'\t\v\r12.34\n'</span>) <span class="comment">// 12.34</span></span><br></pre></td></tr></table></figure></p><h5 id="对对象"><a href="#对对象" class="headerlink" title="对对象"></a>对对象</h5><p>第一步，调用对象自身的valueOf方法。如果返回原始类型的值，则直接对该值使用Number函数，不再进行后续步骤。</p><p>第二步，如果valueOf方法返回的还是对象，则改为调用对象自身的toString方法。如果toString方法返回原始类型的值，则对该值使用Number函数，不再进行后续步骤。</p><p>第三步，如果toString方法返回的是对象，就报错。</p><p><em>默认情况下，对象的valueOf方法返回对象本身，所以一般总是会调用toString方法</em></p><h4 id="String"><a href="#String" class="headerlink" title="String()"></a>String()</h4><p>String函数可以将任意类型的值转化成字符串，转换规则如下。</p><h5 id="原始类型值"><a href="#原始类型值" class="headerlink" title="原始类型值"></a>原始类型值</h5><ul><li>数值：转为相应的字符串。</li><li>字符串：转换后还是原来的值。</li><li>布尔值：true转为字符串”true”，false转为字符串”false”。</li><li>undefined：转为字符串”undefined”。</li><li>null：转为字符串”null”。<h5 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h5>String方法的参数如果是对象，返回一个类型字符串；如果是数组，返回该数组的字符串形式。</li></ul><p>String方法背后的转换规则，与Number方法基本相同，只是互换了valueOf方法和toString方法的执行顺序。</p><ul><li>先调用对象自身的toString方法。如果返回原始类型的值，则对该值使用String函数，不再进行以下步骤。</li><li>如果toString方法返回的是对象，再调用原对象的valueOf方法。如果valueOf方法返回原始类型的值，则对该值使用String函数，不再进行以下步骤。</li><li>如果valueOf方法返回的是对象，就报错。</li></ul><h4 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean()"></a>Boolean()</h4><p>它的转换规则相对简单：除了以下五个值的转换结果为false，其他的值全部为true。</p><ul><li>undefined</li><li>null</li><li>-0或+0</li><li>NaN</li><li>‘’（空字符串）</li></ul><p><strong>注意，所有对象（包括空对象）的转换结果都是true，甚至连false对应的布尔对象new Boolean(false)也是true（详见《原始类型值的包装对象》一章）。</strong></p><h2 id="错误处理机制"><a href="#错误处理机制" class="headerlink" title="错误处理机制"></a>错误处理机制</h2><p>JavaScript 解析或运行时，一旦发生错误，引擎就会抛出一个错误对象。JavaScript 原生提供Error构造函数，所有抛出的错误都是这个构造函数的实例。</p><p>JavaScript 语言标准只提到，Error实例对象必须有message属性，表示出错时的提示信息，没有提到其他属性。大多数 JavaScript 引擎，对Error实例还提供name和stack属性，分别表示错误的名称和错误的堆栈，但它们是非标准的，不是每种实现都有。</p><ul><li>message：错误提示信息</li><li>name：错误名称（非标准属性）</li><li>stack：错误的堆栈（非标准属性）<h3 id="原生错误类型"><a href="#原生错误类型" class="headerlink" title="原生错误类型"></a>原生错误类型</h3>Error实例对象是最一般的错误类型，在它的基础上，JavaScript 还定义了其他6种错误对象。也就是说，存在Error的6个派生对象。<h4 id="SyntaxError-对象"><a href="#SyntaxError-对象" class="headerlink" title="SyntaxError 对象"></a>SyntaxError 对象</h4>SyntaxError对象是解析代码时发生的语法错误。<h4 id="ReferenceError-对象"><a href="#ReferenceError-对象" class="headerlink" title="ReferenceError 对象"></a>ReferenceError 对象</h4></li><li>ReferenceError对象是引用一个不存在的变量时发生的错误。</li><li>另一种触发场景是，将一个值分配给无法分配的对象，比如对函数的运行结果或者this赋值。<h4 id="RangeError-对象"><a href="#RangeError-对象" class="headerlink" title="RangeError 对象"></a>RangeError 对象</h4>RangeError对象是一个值超出有效范围时发生的错误。主要有几种情况，一是数组长度为负数，二是Number对象的方法参数超出范围，以及函数堆栈超过最大值。<h4 id="TypeError-对象"><a href="#TypeError-对象" class="headerlink" title="TypeError 对象"></a>TypeError 对象</h4>TypeError对象是变量或参数不是预期类型时发生的错误。比如，对字符串、布尔值、数值等原始类型的值使用new命令，就会抛出这种错误，因为new命令的参数应该是一个构造函数。</li></ul><p>第二种情况，调用对象不存在的方法，也会抛出TypeError错误，因为obj.unknownMethod的值是undefined，而不是一个函数。</p><h4 id="URIError-对象"><a href="#URIError-对象" class="headerlink" title="URIError 对象"></a>URIError 对象</h4><p>URIError对象是 URI 相关函数的参数不正确时抛出的错误，主要涉及encodeURI()、decodeURI()、encodeURIComponent()、decodeURIComponent()、escape()和unescape()这六个函数。</p><h4 id="EvalError-对象"><a href="#EvalError-对象" class="headerlink" title="EvalError 对象"></a>EvalError 对象</h4><p>eval函数没有被正确执行时，会抛出EvalError错误。该错误类型已经不再使用了，只是为了保证与以前代码兼容，才继续保留。</p><h3 id="自定义错误"><a href="#自定义错误" class="headerlink" title="自定义错误"></a>自定义错误</h3><p>除了 JavaScript 原生提供的七种错误对象，还可以定义自己的错误对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserError</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.message = message || <span class="string">'默认信息'</span>;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'UserError'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UserError.prototype = <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">UserError.prototype.constructor = UserError;</span><br></pre></td></tr></table></figure></p><p>上面代码自定义一个错误对象UserError，让它继承Error对象。然后，就可以生成这种自定义类型的错误了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> UserError(<span class="string">'这是自定义的错误！'</span>);</span><br></pre></td></tr></table></figure></p><h3 id="throw-语句"><a href="#throw-语句" class="headerlink" title="throw 语句"></a>throw 语句</h3><p>throw语句的作用是手动中断程序执行，抛出一个错误。</p><p>实际上，throw可以抛出任何类型的值。也就是说，它的参数可以是任何值。</p><p>对于 JavaScript 引擎来说，遇到throw语句，程序就中止了。引擎会接收到throw抛出的信息，可能是一个错误实例，也可能是其他类型的值。</p><h3 id="try…catch-结构"><a href="#try…catch-结构" class="headerlink" title="try…catch 结构"></a>try…catch 结构</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'出错了!'</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.name + <span class="string">": "</span> + e.message);</span><br><span class="line">  <span class="built_in">console</span>.log(e.stack);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Error: 出错了!</span></span><br><span class="line"><span class="comment">//   at &lt;anonymous&gt;:3:9</span></span><br><span class="line"><span class="comment">//   ...</span></span><br></pre></td></tr></table></figure><p>try…catch结构允许在最后添加一个finally代码块，表示不管是否出现错误，都必需在最后运行的语句。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;语法专题&quot;&gt;&lt;a href=&quot;#语法专题&quot; class=&quot;headerlink&quot; title=&quot;语法专题&quot;&gt;&lt;/a&gt;语法专题&lt;/h1&gt;&lt;h2 id=&quot;数据类型的转换&quot;&gt;&lt;a href=&quot;#数据类型的转换&quot; class=&quot;headerlink&quot; title=&quot;数据类
      
    
    </summary>
    
      <category term="学习笔记" scheme="https://minoyu.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JavaScript" scheme="https://minoyu.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JavaScript/"/>
    
    
      <category term="《JavaScript 标准参考教程-阮一峰》" scheme="https://minoyu.github.io/tags/%E3%80%8AJavaScript-%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B-%E9%98%AE%E4%B8%80%E5%B3%B0%E3%80%8B/"/>
    
      <category term="学习笔记" scheme="https://minoyu.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>我的JavaScript简略学习笔记02(运算符)</title>
    <link href="https://minoyu.github.io/2019/01/23/%E6%88%91%E7%9A%84JavaScript%E7%AE%80%E7%95%A5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/"/>
    <id>https://minoyu.github.io/2019/01/23/我的JavaScript简略学习笔记02/</id>
    <published>2019-01-23T13:50:27.000Z</published>
    <updated>2019-01-24T07:49:40.714Z</updated>
    
    <content type="html"><![CDATA[<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h2><blockquote><p>JavaScript 共提供10个算术运算符，用来完成基本的算术运算。</p></blockquote><ul><li>加法运算符：<code>x + y</code></li><li>减法运算符： <code>x - y</code></li><li>乘法运算符： <code>x * y</code></li><li>除法运算符：<code>x / y</code></li><li>指数运算符：<code>x ** y //x的y次方</code></li><li>余数运算符：<code>x % y</code></li><li>自增运算符：<code>++x 或者 x++</code></li><li>自减运算符：<code>--x 或者 x--</code></li><li>数值运算符：<code>+x</code></li><li>负数值运算符：<code>-x</code></li></ul><p>减法、乘法、除法运算法比较单纯，就是执行相应的数学运算 下面介绍其他几个算术运算符，重点是加法运算符。</p><h3 id="加法运算符"><a href="#加法运算符" class="headerlink" title="加法运算符"></a>加法运算符</h3><p>JavaScript 允许非数值的相加。</p><ul><li>布尔值都会自动转成数值，然后再相加。</li><li>两个字符串相加，这时加法运算符会变成连接运算符，返回一个新的字符串，将两个原字符串连接在一起。</li><li>一个运算子是字符串，另一个运算子是非字符串，这时非字符串会转成字符串，再连接在一起。<h4 id="对象的相加"><a href="#对象的相加" class="headerlink" title="对象的相加"></a>对象的相加</h4>如果运算子是对象，必须先转成原始类型的值，然后再相加。首先，自动调用对象的valueOf方法,一般来说，对象的valueOf方法总是返回对象自身。这时再自动调用对象的toString方法，将其转为字符串。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">p</span>: <span class="number">1</span> &#125;;</span><br><span class="line">obj + <span class="number">2</span> <span class="comment">// "[object Object]2"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">p</span>: <span class="number">1</span> &#125;;</span><br><span class="line">obj.valueOf().toString() <span class="comment">// "[object Object]"</span></span><br></pre></td></tr></table></figure></li></ul><p>知道了这个规则以后，就可以自己定义valueOf方法或toString方法，得到想要的结果。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  valueOf: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj + <span class="number">2</span> <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p><h3 id="余数运算符"><a href="#余数运算符" class="headerlink" title="余数运算符"></a>余数运算符</h3><p>需要注意的是，运算结果的正负号由第一个运算子的正负号决定。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">-1</span> % <span class="number">2</span> <span class="comment">// -1</span></span><br><span class="line"><span class="number">1</span> % <span class="number">-2</span> <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p><h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><p>JavaScript 一共提供了8个比较运算符。</p><ul><li><code>&gt;</code> 大于运算符</li><li><code>&lt;</code> 小于运算符</li><li><code>&lt;=</code> 小于或等于运算符</li><li><code>&gt;=</code> 大于或等于运算符</li><li><code>==</code> 相等运算符</li><li><code>===</code> 严格相等运算符</li><li><code>!=</code> 不相等运算符</li><li><code>!==</code> 严格不相等运算符</li></ul><h3 id="非相等运算符"><a href="#非相等运算符" class="headerlink" title="非相等运算符"></a>非相等运算符</h3><ul><li>在进行字符串比较时，字符串按照字典顺序进行比较。JavaScript 引擎内部首先比较首字符的 Unicode 码点。如果相等，再比较第二个字符的 Unicode 码点，以此类推。</li><li><ul><li>非字符串的比较时，如果两个运算子都是原始类型的值，则是先转成数值再比较。这里需要注意与NaN的比较。任何值（包括NaN本身）与NaN比较，返回的都是false。 </li><li>如果运算子是对象，会转为原始类型的值，再进行比较。先调用valueOf方法，如果返回的还是对象，再接着调用toString方法<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = [<span class="number">2</span>];</span><br><span class="line">x &gt; <span class="string">'11'</span> <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 等同于 [2].valueOf().toString() &gt; '11'</span></span><br><span class="line"><span class="comment">// 即 '2' &gt; '11'</span></span><br><span class="line"></span><br><span class="line">x.valueOf = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">'1'</span> &#125;;</span><br><span class="line">x &gt; <span class="string">'11'</span> <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 等同于 [2].valueOf() &gt; '11'</span></span><br><span class="line"><span class="comment">// 即 '1' &gt; '11'</span></span><br><span class="line"></span><br><span class="line">[<span class="number">2</span>] &gt; [<span class="number">1</span>] <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 等同于 [2].valueOf().toString() &gt; [1].valueOf().toString()</span></span><br><span class="line"><span class="comment">// 即 '2' &gt; '1'</span></span><br><span class="line"></span><br><span class="line">[<span class="number">2</span>] &gt; [<span class="number">11</span>] <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 等同于 [2].valueOf().toString() &gt; [11].valueOf().toString()</span></span><br><span class="line"><span class="comment">// 即 '2' &gt; '11'</span></span><br><span class="line"></span><br><span class="line">&#123; <span class="attr">x</span>: <span class="number">2</span> &#125; &gt;= &#123; <span class="attr">x</span>: <span class="number">1</span> &#125; <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 等同于 &#123; x: 2 &#125;.valueOf().toString() &gt;= &#123; x: 1 &#125;.valueOf().toString()</span></span><br><span class="line"><span class="comment">// 即 '[object Object]' &gt;= '[object Object]'</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="严格相等运算符"><a href="#严格相等运算符" class="headerlink" title="严格相等运算符"></a>严格相等运算符</h3><p>JavaScript 提供两种相等运算符：==和===。</p><p>简单说，它们的区别是相等运算符（==）比较两个值是否相等，严格相等运算符（===）比较它们是否为“同一个值”。如果两个值不是同一类型，严格相等运算符（===）直接返回false，而相等运算符（==）会将它们转换成同一个类型，再用严格相等运算符进行比较。</p><ul><li>如果两个值的类型不同，直接返回false。</li><li>同一类型的原始类型的值（数值、字符串、布尔值）比较时，值相同就返回true，值不同就返回false。需要注意的是，NaN与任何值都不相等（包括自身）。另外，正0等于负0。</li><li>两个复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个地址。</li><li>undefined和null与自身严格相等。</li></ul><h3 id="相等运算符"><a href="#相等运算符" class="headerlink" title="相等运算符"></a>相等运算符</h3><ul><li>相等运算符用来比较相同类型的数据时，与严格相等运算符完全一样。</li><li>原始类型的值会转换成数值再进行比较。</li><li>对象（这里指广义的对象，包括数组和函数）与原始类型的值比较时，对象转换成原始类型的值，再进行比较。 </li><li>undefined和null与其他类型的值比较时，结果都为false，它们互相比较时结果为true。</li></ul><p>相等运算符隐藏的类型转换，会带来一些违反直觉的结果。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> == <span class="string">''</span>             <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> == <span class="string">'0'</span>            <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span> == <span class="literal">true</span>           <span class="comment">// false</span></span><br><span class="line"><span class="number">2</span> == <span class="literal">false</span>          <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="literal">false</span> == <span class="string">'false'</span>    <span class="comment">// false</span></span><br><span class="line"><span class="literal">false</span> == <span class="string">'0'</span>        <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="literal">false</span> == <span class="literal">undefined</span>  <span class="comment">// false</span></span><br><span class="line"><span class="literal">false</span> == <span class="literal">null</span>       <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span>   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="string">' \t\r\n '</span> == <span class="number">0</span>     <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p>上面这些表达式都不同于直觉，很容易出错。因此建议不要使用相等运算符（==），最好只使用严格相等运算符（===）。</p><h2 id="布尔运算符"><a href="#布尔运算符" class="headerlink" title="布尔运算符"></a>布尔运算符</h2><p>布尔运算符用于将表达式转为布尔值，一共包含四个运算符。</p><ul><li>取反运算符：!</li><li>且运算符：&amp;&amp;</li><li>或运算符：||</li><li>三元运算符：?:</li></ul><h3 id="取反运算符（-）"><a href="#取反运算符（-）" class="headerlink" title="取反运算符（!）"></a>取反运算符（!）</h3><p>对于非布尔值，取反运算符会将其转为布尔值。可以这样记忆，以下六个值取反后为true，其他值都为false。</p><ul><li>undefined</li><li>null</li><li>false</li><li>0</li><li>NaN</li><li>空字符串（’’）<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">!<span class="literal">undefined</span> <span class="comment">// true</span></span><br><span class="line">!<span class="literal">null</span> <span class="comment">// true</span></span><br><span class="line">!<span class="number">0</span> <span class="comment">// true</span></span><br><span class="line">!<span class="literal">NaN</span> <span class="comment">// true</span></span><br><span class="line">!<span class="string">""</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">!<span class="number">54</span> <span class="comment">// false</span></span><br><span class="line">!<span class="string">'hello'</span> <span class="comment">// false</span></span><br><span class="line">![] <span class="comment">// false</span></span><br><span class="line">!&#123;&#125; <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="且（或）运算符（-amp-amp-）"><a href="#且（或）运算符（-amp-amp-）" class="headerlink" title="且（或）运算符（&amp;&amp; ||）"></a>且（或）运算符（&amp;&amp; ||）</h3><p>如果第一个运算子的布尔值为true，则返回第二个运算子的值（<strong>注意是值，不是布尔值</strong>）；如果第一个运算子的布尔值为false，则直接返回第一个运算子的值，且不再对第二个运算子求值。</p><blockquote><p>或运算符（||）同理 也用于多个表达式的求值。它的运算规则是：如果第一个运算子的布尔值为true，则返回第一个运算子的值，且不再对第二个运算子求值；如果第一个运算子的布尔值为false，则返回第二个运算子的值。</p></blockquote><p><del>神奇的JS</del><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'t'</span> &amp;&amp; <span class="string">''</span> <span class="comment">// ""</span></span><br><span class="line"><span class="string">'t'</span> &amp;&amp; <span class="string">'f'</span> <span class="comment">// "f"</span></span><br><span class="line"><span class="string">'t'</span> &amp;&amp; (<span class="number">1</span> + <span class="number">2</span>) <span class="comment">// 3</span></span><br><span class="line"><span class="string">''</span> &amp;&amp; <span class="string">'f'</span> <span class="comment">// ""</span></span><br><span class="line"><span class="string">''</span> &amp;&amp; <span class="string">''</span> <span class="comment">// ""</span></span><br><span class="line"></span><br><span class="line"><span class="string">'t'</span> || <span class="string">''</span> <span class="comment">// "t"</span></span><br><span class="line"><span class="string">'t'</span> || <span class="string">'f'</span> <span class="comment">// "t"</span></span><br><span class="line"><span class="string">''</span> || <span class="string">'f'</span> <span class="comment">// "f"</span></span><br><span class="line"><span class="string">''</span> || <span class="string">''</span> <span class="comment">// ""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">(<span class="number">1</span> - <span class="number">1</span>) &amp;&amp; ( x += <span class="number">1</span>) <span class="comment">// 0</span></span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="literal">true</span> || (x = <span class="number">2</span>) <span class="comment">// true</span></span><br><span class="line">x <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p><p>有些程序员喜欢用它取代if结构，比如下面是一段if结构的代码，就可以用且运算符改写。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i) &#123;</span><br><span class="line">  doSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"></span><br><span class="line">i &amp;&amp; doSomething();</span><br></pre></td></tr></table></figure></p><p>或运算符常用于为一个变量设置默认值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">saveText</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">  text = text || <span class="string">''</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者写成</span></span><br><span class="line">saveText(<span class="keyword">this</span>.text || <span class="string">''</span>)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;运算符&quot;&gt;&lt;a href=&quot;#运算符&quot; class=&quot;headerlink&quot; title=&quot;运算符&quot;&gt;&lt;/a&gt;运算符&lt;/h1&gt;&lt;h2 id=&quot;算数运算符&quot;&gt;&lt;a href=&quot;#算数运算符&quot; class=&quot;headerlink&quot; title=&quot;算数运算符&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="学习笔记" scheme="https://minoyu.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JavaScript" scheme="https://minoyu.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JavaScript/"/>
    
    
      <category term="《JavaScript 标准参考教程-阮一峰》" scheme="https://minoyu.github.io/tags/%E3%80%8AJavaScript-%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B-%E9%98%AE%E4%B8%80%E5%B3%B0%E3%80%8B/"/>
    
      <category term="学习笔记" scheme="https://minoyu.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>我的JavaScript简略学习笔记01(基本语法、数据类型)</title>
    <link href="https://minoyu.github.io/2018/11/08/%E6%88%91%E7%9A%84JavaScript%E7%AE%80%E7%95%A5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://minoyu.github.io/2018/11/08/我的JavaScript简略学习笔记01-基本语法、数据类型/</id>
    <published>2018-11-07T20:12:11.000Z</published>
    <updated>2019-01-23T12:51:49.732Z</updated>
    
    <content type="html"><![CDATA[<p>最近准备系统性的过一遍阮一峰的JavaScript教程，因为看的比较快速所以可能只能在这里简略的记录一些关键的地方了，希望这次能对JS的认识更全面一些吧。哈哈加油！那么下面开始咯。</p><p>总结自<a href="https://wangdoc.com/javascript/" target="_blank" rel="noopener">阮一峰JavaScript教程</a></p><h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><p>最前面的var，是变量声明命令。它表示通知解释引擎，要创建一个变量a。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p><p>注意，JavaScript 的变量名区分大小写，A和a是两个不同的变量。</p><p>如果只是声明变量而没有赋值，则该变量的值是undefined。undefined是一个特殊的值，表示“无定义”。</p><p>如果变量赋值的时候，忘了写var命令，这条语句也是有效的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 基本等同</span></span><br><span class="line">a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p><p>但是，不写var的做法，不利于表达意图，而且容易不知不觉地创建全局变量，所以建议总是使用<code>var</code>命令声明变量。</p><p>如果一个变量没有声明就直接使用，JavaScript 会报错，告诉你变量未定义。</p><p><strong>JavaScript 是一种动态类型语言，也就是说，变量的类型没有限制，变量可以随时更改类型。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">a = <span class="string">'hello'</span>;</span><br></pre></td></tr></table></figure><p>如果使用var重新声明一个已经存在的变量，是无效的。<br>但是，如果第二次声明的时候还进行了赋值，则会覆盖掉前面的值。</p><h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><p>JavaScript 引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升（hoisting）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>上面代码首先使用console.log方法，在控制台（console）显示变量a的值。这时变量a还没有声明和赋值，所以这是一种错误的做法，但是实际上不会报错。因为存在变量提升，真正运行的是下面的代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line">a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>最后的结果是显示undefined，表示变量a已声明，但还未赋值。</p><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>简单说，标识符命名规则如下。</p><ul><li>第一个字符，可以是任意 Unicode 字母（包括英文字母和其他语言的字母），以及美元符号（$）和下划线（_）。</li><li>第二个字符及后面的字符，除了 Unicode 字母、美元符号和下划线，还可以用数字0-9。</li></ul><blockquote><p>JavaScript 有一些保留字，不能用作标识符：arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield。</p></blockquote><h2 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h2><p>JavaScript 使用大括号，将多个相关的语句组合在一起，称为“区块”（block）。</p><p>对于var命令来说，JavaScript 的区块不构成单独的作用域（scope）。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p><p>上面代码在区块内部，使用var命令声明并赋值了变量a，然后在区块外部，变量a依然有效，区块对于var命令不构成单独的作用域，与不使用区块的情况没有任何区别。在 JavaScript 语言中，单独使用区块并不常见，区块往往用来构成其他更复杂的语法结构，比如for、if、while、function等。</p><h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><p>JavaScript 提供if结构和switch结构，完成条件判断，即只有满足预设的条件，才会执行相应的语句。</p><p>这部分简略</p><p>注意，if后面的表达式之中，不要混淆赋值表达式（<code>=</code>）、严格相等运算符（<code>===</code>）和相等运算符（<code>==</code>）。</p><p>至于为什么优先采用“严格相等运算符”（<code>===</code>），而不是“相等运算符”（<code>==</code>），请参考《运算符》章节。</p><h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><p><code>while</code> <code>for</code> <code>do...while</code></p><p><code>break 语句和 continue 语句</code><br>不再详细介绍<br><a href="https://wangdoc.com/javascript/basic/grammar.html#%E5%8F%98%E9%87%8F" target="_blank" rel="noopener">传送门</a></p><h2 id="标签（label）"><a href="#标签（label）" class="headerlink" title="标签（label）"></a>标签（label）</h2><p>JavaScript 语言允许，语句的前面有标签（label），相当于定位符，用于跳转到程序的任意位置，标签的格式如下。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">label:</span><br><span class="line">  语句</span><br></pre></td></tr></table></figure></p><p>标签可以是任意的标识符，但不能是保留字，语句部分可以是任意语句。</p><p>标签通常与break语句和continue语句配合使用，跳出特定的循环。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">top:</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span> (i === <span class="number">1</span> &amp;&amp; j === <span class="number">1</span>) <span class="keyword">break</span> top;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'i='</span> + i + <span class="string">', j='</span> + j);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// i=0, j=0</span></span><br><span class="line"><span class="comment">// i=0, j=1</span></span><br><span class="line"><span class="comment">// i=0, j=2</span></span><br><span class="line"><span class="comment">// i=1, j=0</span></span><br></pre></td></tr></table></figure><p>上面代码为一个双重循环区块，break命令后面加上了top标签（注意，top不用加引号），满足条件时，直接跳出双层循环。如果break语句后面不使用标签，则只能跳出内层循环，进入下一次的外层循环。</p><p>标签也可以用于跳出代码块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">foo: &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">break</span> foo;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'本行不会输出'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>上面代码执行到break foo，就会跳出区块。</p><p>continue语句也可以与标签配合使用。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">top:</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span> (i === <span class="number">1</span> &amp;&amp; j === <span class="number">1</span>) <span class="keyword">continue</span> top;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'i='</span> + i + <span class="string">', j='</span> + j);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// i=0, j=0</span></span><br><span class="line"><span class="comment">// i=0, j=1</span></span><br><span class="line"><span class="comment">// i=0, j=2</span></span><br><span class="line"><span class="comment">// i=1, j=0</span></span><br><span class="line"><span class="comment">// i=2, j=0</span></span><br><span class="line"><span class="comment">// i=2, j=1</span></span><br><span class="line"><span class="comment">// i=2, j=2</span></span><br></pre></td></tr></table></figure></p><p>上面代码中，continue命令后面有一个标签名，满足条件时，会跳过当前循环，直接进入下一轮外层循环。如果continue语句后面不使用标签，则只能进入下一轮的内层循环。</p><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>JavaScript 语言的每一个值，都属于某一种数据类型。JavaScript 的数据类型，共有六种。（ES6 又新增了第七种 Symbol 类型的值</p><ul><li>数值（number）：整数和小数（比如1和3.14）</li><li>字符串（string）：文本（比如Hello World）。</li><li>布尔值（boolean）：表示真伪的两个特殊值，即true（真）和false（假）</li><li>undefined：表示“未定义”或不存在，即由于目前没有定义，所以此处暂时没有任何值</li><li>null：表示空值，即此处的值为空。</li><li>对象（object）：各种值组成的集合。</li></ul><p>通常，<strong>数值</strong>、<strong>字符串</strong>、<strong>布尔值</strong>这三种类型，合称为原始类型（primitive type）的值，即它们是最基本的数据类型，不能再细分了。</p><p>对象则称为合成类型（complex type）的值，因为一个对象往往是多个原始类型的值的合成，可以看作是一个存放各种值的容器。</p><p>至于undefined和null，一般将它们看成两个特殊值。</p><p>对象是最复杂的数据类型，又可以分成三个子类型。</p><ul><li>狭义的对象（object）</li><li>数组（array）</li><li>函数（function）</li></ul><p>狭义的对象和数组是两种不同的数据组合方式，除非特别声明，本教程的”对象“都特指狭义的对象。函数其实是处理数据的方法，JavaScript 把它当成一种数据类型，可以赋值给变量，这为编程带来了很大的灵活性，也为 JavaScript 的“函数式编程”奠定了基础。</p><h2 id="typeof-运算符"><a href="#typeof-运算符" class="headerlink" title="typeof 运算符"></a>typeof 运算符</h2><p>JavaScript 有三种方法，可以确定一个值到底是什么类型。</p><ul><li>typeof运算符</li><li>instanceof运算符</li><li>Object.prototype.toString方法</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">123</span> <span class="comment">// "number"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">'123'</span> <span class="comment">// "string"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">false</span> <span class="comment">// "boolean"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">typeof</span> f</span><br><span class="line"><span class="comment">// "function"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span></span><br><span class="line"><span class="comment">// "undefined"</span></span><br></pre></td></tr></table></figure><p>利用这一点，typeof可以用来检查一个没有声明的变量，而不报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">v</span><br><span class="line"><span class="comment">// ReferenceError: v is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> v</span><br><span class="line"><span class="comment">// "undefined"</span></span><br></pre></td></tr></table></figure><p>上面代码中，变量v没有用var命令声明，直接使用就会报错。但是，放在typeof后面，就不报错了，而是返回undefined。</p><p>实际编程中，这个特点通常用在判断语句。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的写法</span></span><br><span class="line"><span class="keyword">if</span> (v) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ReferenceError: v is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的写法</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> v === <span class="string">"undefined"</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对象返回<code>object</code>.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="built_in">window</span> <span class="comment">// "object"</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125; <span class="comment">// "object"</span></span><br><span class="line"><span class="keyword">typeof</span> [] <span class="comment">// "object"</span></span><br></pre></td></tr></table></figure></p><p>上面代码中，空数组（[]）的类型也是object，这表示在 JavaScript 内部，数组本质上只是一种特殊的对象。这里顺便提一下，instanceof运算符可以区分数组和对象。instanceof运算符的详细解释，请见《面向对象编程》一章。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"></span><br><span class="line">o <span class="keyword">instanceof</span> <span class="built_in">Array</span> <span class="comment">// false</span></span><br><span class="line">a <span class="keyword">instanceof</span> <span class="built_in">Array</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>null</code>返回<code>object</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">// "object"</span></span><br></pre></td></tr></table></figure><p>null的类型是object，这是由于历史原因造成的。1995年的 JavaScript 语言第一版，只设计了五种数据类型（对象、整数、浮点数、字符串和布尔值），没考虑null，只把它当作object的一种特殊值。后来null独立出来，作为一种单独的数据类型，为了兼容以前的代码，typeof null返回object就没法改变了。</p><h2 id="null-和-undefined"><a href="#null-和-undefined" class="headerlink" title="null 和 undefined"></a>null 和 undefined</h2><p>null与undefined都可以表示“没有”，含义非常相似。将一个变量赋值为undefined或null，老实说，语法效果几乎没区别。</p><p>在if语句中，它们都会被自动转为false，相等运算符（==）甚至直接报告两者相等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="literal">undefined</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'undefined is false'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// undefined is false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'null is false'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// null is false</span></span><br><span class="line"></span><br><span class="line"><span class="literal">undefined</span> == <span class="literal">null</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>从上面代码可见，两者的行为是何等相似！谷歌公司开发的 JavaScript 语言的替代品 Dart 语言，就明确规定只有null，没有undefined！</p><p>既然含义与用法都差不多，为什么要同时设置两个这样的值，这不是无端增加复杂度，令初学者困扰吗？这与历史原因有关。1995年 JavaScript 诞生时，最初像 Java 一样，只设置了null表示”无”。根据 C 语言的传统，null可以自动转为0。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="literal">null</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="number">5</span> + <span class="literal">null</span> <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>但是，JavaScript 的设计者 Brendan Eich，觉得这样做还不够。首先，第一版的 JavaScript 里面，null就像在 Java 里一样，被当成一个对象，Brendan Eich 觉得表示“无”的值最好不是对象。其次，那时的 JavaScript 不包括错误处理机制，Brendan Eich 觉得，如果null自动转为0，很不容易发现错误。</p><p>因此，他又设计了一个undefined。区别是这样的：null是一个表示“空”的对象，转为数值时为0；undefined是一个表示”此处无定义”的原始值，转为数值时为NaN。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="literal">undefined</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="number">5</span> + <span class="literal">undefined</span> <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><h3 id="用法和定义"><a href="#用法和定义" class="headerlink" title="用法和定义"></a>用法和定义</h3><p>null表示空值，即该处的值现在为空。调用函数时，某个参数未设置任何值，这时就可以传入null，表示该参数为空。比如，某个函数接受引擎抛出的错误作为参数，如果运行过程中未出错，那么这个参数就会传入null，表示未发生错误。</p><p>undefined表示“未定义”。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量声明了，但没有赋值</span></span><br><span class="line"><span class="keyword">var</span> i;</span><br><span class="line">i <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用函数时，应该提供的参数没有提供，该参数等于 undefined</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line">f() <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象没有赋值的属性</span></span><br><span class="line"><span class="keyword">var</span>  o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">o.p <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数没有返回值时，默认返回 undefined</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">f() <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></p><h2 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h2><p>“真”用关键字true表示，“假”用关键字false表示。布尔值只有这两个值。</p><p>下列运算符会返回布尔值：</p><ul><li>前置逻辑运算符： ! (Not)</li><li>相等运算符：===，!==，==，!=</li><li>比较运算符：&gt;，&gt;=，&lt;，&lt;=</li></ul><p>如果 JavaScript 预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。转换规则是除了下面六个值被转为false，其他值都视为true。</p><ul><li>undefined</li><li>null</li><li>false</li><li>0</li><li>NaN</li><li>“”或’’（空字符串）</li></ul><p><strong>注意，空数组（[]）和空对象（{}）对应的布尔值，都是true。</strong></p><h2 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><h4 id="整数和浮点数"><a href="#整数和浮点数" class="headerlink" title="整数和浮点数"></a>整数和浮点数</h4><p>JavaScript 内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。所以，1与1.0是相同的，是同一个数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> === <span class="number">1.0</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这就是说，JavaScript 语言的底层根本没有整数，所有数字都是小数（64位浮点数）。由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.3</span></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="number">0.3</span> / <span class="number">0.1</span></span><br><span class="line"><span class="comment">// 2.9999999999999996</span></span><br><span class="line"></span><br><span class="line">(<span class="number">0.3</span> - <span class="number">0.2</span>) === (<span class="number">0.2</span> - <span class="number">0.1</span>)</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure><h4 id="数值精度"><a href="#数值精度" class="headerlink" title="数值精度"></a>数值精度</h4><p>根据国际标准 IEEE 754，JavaScript 浮点数的64个二进制位，从最左边开始，是这样组成的。</p><ul><li>第1位：符号位，0表示正数，1表示负数</li><li>第2位到第12位（共11位）：指数部分</li><li>第13位到第64位（共52位）：小数部分（即有效数字）</li></ul><p>符号位决定了一个数的正负，指数部分决定了数值的大小，小数部分决定了数值的精度。</p><p>指数部分一共有11个二进制位，因此大小范围就是0到2047。IEEE 754 规定，如果指数部分的值在0到2047之间（不含两个端点），那么有效数字的第一位默认总是1，不保存在64位浮点数之中。也就是说，有效数字这时总是1.xx…xx的形式，其中xx..xx的部分保存在64位浮点数之中，最长可能为52位。因此，JavaScript 提供的有效数字最长为53个二进制位。</p><p>精度最多只能到53个二进制位，这意味着，绝对值小于2的53次方的整数，即-253到253，都可以精确表示。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>)</span><br><span class="line"><span class="comment">// 9007199254740992</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">1</span></span><br><span class="line"><span class="comment">// 9007199254740992</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">2</span></span><br><span class="line"><span class="comment">// 9007199254740994</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">3</span></span><br><span class="line"><span class="comment">// 9007199254740996</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">4</span></span><br><span class="line"><span class="comment">// 9007199254740996</span></span><br></pre></td></tr></table></figure><p>上面代码中，大于2的53次方以后，整数运算的结果开始出现错误。所以，大于2的53次方的数值，都无法保持精度。由于2的53次方是一个16位的十进制数值，所以简单的法则就是<strong>，JavaScript 对15位的十进制数都可以精确处理</strong>。</p><h4 id="数值范围"><a href="#数值范围" class="headerlink" title="数值范围"></a>数值范围</h4><p>根据标准，64位浮点数的指数部分的长度是11个二进制位，意味着指数部分的最大值是2047（2的11次方减1）。也就是说，64位浮点数的指数部分的值最大为2047，分出一半表示负数，则 JavaScript 能够表示的数值范围为21024到2-1023（开区间），超出这个范围的数无法表示</p><p>如果一个数大于等于2的1024次方，那么就会发生“正向溢出”，即 JavaScript 无法表示这么大的数，这时就会返回Infinity。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">1024</span>) <span class="comment">// Infinity</span></span><br></pre></td></tr></table></figure><p>如果一个数小于等于2的-1075次方（指数部分最小值-1023，再加上小数部分的52位），那么就会发生为“负向溢出”，即 JavaScript 无法表示这么小的数，这时会直接返回0。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">-1075</span>) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure></p><p>JavaScript 提供Number对象的MAX_VALUE和MIN_VALUE属性，返回可以表示的具体的最大值和最小值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.MAX_VALUE <span class="comment">// 1.7976931348623157e+308</span></span><br><span class="line"><span class="built_in">Number</span>.MIN_VALUE <span class="comment">// 5e-324</span></span><br></pre></td></tr></table></figure><h3 id="数值的表示法"><a href="#数值的表示法" class="headerlink" title="数值的表示法"></a>数值的表示法</h3><p>JavaScript 的数值有多种表示方法，可以用字面形式直接表示，比如35（十进制）和0xFF（十六进制）。数值也可以采用科学计数法表示.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123e3</span> <span class="comment">// 123000</span></span><br><span class="line"><span class="number">123e-3</span> <span class="comment">// 0.123</span></span><br><span class="line"><span class="number">-3.1E+12</span></span><br><span class="line"><span class="number">.1e-23</span></span><br></pre></td></tr></table></figure></p><p>小数点前的数字多于21位 或 小数点后的零多于5个 两种情况下，JavaScript 会自动将数值转为科学计数法表示，其他情况都采用字面形式直接表示。</p><h3 id="数值的进制"><a href="#数值的进制" class="headerlink" title="数值的进制"></a>数值的进制</h3><ul><li>十进制：没有前导0的数值。</li><li>八进制：有前缀0o或0O的数值，或者有前导0、且只用到0-7的八个阿拉伯数字的数值。</li><li>十六进制：有前缀0x或0X的数值。</li><li>二进制：有前缀0b或0B的数值。</li></ul><p>前导0表示八进制，处理时很容易造成混乱。ES5 的严格模式和 ES6，已经废除了这种表示法，但是浏览器为了兼容以前的代码，目前还继续支持这种表示法。</p><h3 id="特殊数值"><a href="#特殊数值" class="headerlink" title="特殊数值"></a>特殊数值</h3><p>JavaScript 提供了几个特殊的数值。</p><h4 id="正零和负零"><a href="#正零和负零" class="headerlink" title="正零和负零"></a>正零和负零</h4><p>JavaScript 内部实际上存在2个0：一个是+0，一个是-0，区别就是64位浮点数表示法的符号位不同。它们是等价的。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">-0</span> === +<span class="number">0</span> <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> === <span class="number">-0</span> <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> === +<span class="number">0</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p>几乎所有场合，正零和负零都会被当作正常的0。唯一有区别的场合是，+0或-0当作分母，返回的值是不相等的。之所以出现这样结果，是因为除以正零得到+Infinity，除以负零得到-Infinity，这两者是不相等的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+<span class="number">0</span> <span class="comment">// 0</span></span><br><span class="line"><span class="number">-0</span> <span class="comment">// 0</span></span><br><span class="line">(<span class="number">-0</span>).toString() <span class="comment">// '0'</span></span><br><span class="line">(+<span class="number">0</span>).toString() <span class="comment">// '0'</span></span><br><span class="line">(<span class="number">1</span> / +<span class="number">0</span>) === (<span class="number">1</span> / <span class="number">-0</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h4 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h4><h5 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h5><p>NaN是 JavaScript 的特殊值，表示“非数字”（Not a Number），主要出现在将字符串解析成数字出错的场合。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> - <span class="string">'x'</span> <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><p>另外，一些数学函数的运算结果会出现NaN。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.acos(<span class="number">2</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.log(<span class="number">-1</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.sqrt(<span class="number">-1</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure></p><p>0除以0也会得到NaN。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>/<span class="number">0</span><span class="comment">//NaN</span></span><br></pre></td></tr></table></figure></p><p><strong>需要注意的是，NaN不是独立的数据类型，而是一个特殊数值，它的数据类型依然属于Number。</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">NaN</span> <span class="comment">// 'number'</span></span><br></pre></td></tr></table></figure></p><h5 id="运算规则"><a href="#运算规则" class="headerlink" title="运算规则"></a>运算规则</h5><p>NaN不等于任何值，包括它本身。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p><p>数组的indexOf方法内部使用的是严格相等运算符，所以该方法对NaN不成立。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="literal">NaN</span>].indexOf(<span class="literal">NaN</span>) <span class="comment">// -1</span></span><br></pre></td></tr></table></figure></p><p>NaN在布尔运算时被当作false。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>(<span class="literal">NaN</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p><p>NaN与任何数（包括它自己）的运算，得到的都是NaN。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">NaN</span> + <span class="number">32</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">NaN</span> - <span class="number">32</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">NaN</span> * <span class="number">32</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">NaN</span> / <span class="number">32</span> <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure></p><h4 id="Infinity"><a href="#Infinity" class="headerlink" title="Infinity"></a>Infinity</h4><h5 id="含义-1"><a href="#含义-1" class="headerlink" title="含义"></a>含义</h5><p>Infinity表示“无穷”，用来表示两种场景。一种是一个正的数值太大，或一个负的数值太小，无法表示；另一种是非0数值除以0，得到Infinity。</p><p>Infinity有正负之分，Infinity表示正的无穷，-Infinity表示负的无穷。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">Infinity</span> === -<span class="literal">Infinity</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> / <span class="number">-0</span> <span class="comment">// -Infinity</span></span><br><span class="line"><span class="number">-1</span> / <span class="number">-0</span> <span class="comment">// Infinity</span></span><br></pre></td></tr></table></figure></p><p>Infinity大于一切数值（除了NaN），-Infinity小于一切数值（除了NaN）。</p><p>Infinity与NaN比较，总是返回false。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">Infinity</span> &gt; <span class="literal">NaN</span> <span class="comment">// false</span></span><br><span class="line">-<span class="literal">Infinity</span> &gt; <span class="literal">NaN</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="literal">Infinity</span> &lt; <span class="literal">NaN</span> <span class="comment">// false</span></span><br><span class="line">-<span class="literal">Infinity</span> &lt; <span class="literal">NaN</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p><h5 id="运算规则-1"><a href="#运算规则-1" class="headerlink" title="运算规则"></a>运算规则</h5><p>Infinity的四则运算，符合无穷的数学计算规则。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> * <span class="literal">Infinity</span> <span class="comment">// Infinity</span></span><br><span class="line"><span class="number">5</span> - <span class="literal">Infinity</span> <span class="comment">// -Infinity</span></span><br><span class="line"><span class="literal">Infinity</span> / <span class="number">5</span> <span class="comment">// Infinity</span></span><br><span class="line"><span class="number">5</span> / <span class="literal">Infinity</span> <span class="comment">// 0</span></span><br></pre></td></tr></table></figure></p><p>0乘以Infinity，返回NaN；0除以Infinity，返回0；Infinity除以0，返回Infinity。</p><p>Infinity加上或乘以Infinity，返回的还是Infinity。</p><p>Infinity减去或除以Infinity，得到NaN。</p><p>Infinity与null计算时，null会转成0，等同于与0的计算。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span> * <span class="literal">Infinity</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">null</span> / <span class="literal">Infinity</span> <span class="comment">// 0</span></span><br><span class="line"><span class="literal">Infinity</span> / <span class="literal">null</span> <span class="comment">// Infinity</span></span><br></pre></td></tr></table></figure></p><p>Infinity与undefined计算，返回的都是NaN。</p><h3 id="与数值相关的全局方法"><a href="#与数值相关的全局方法" class="headerlink" title="与数值相关的全局方法"></a>与数值相关的全局方法</h3><h4 id="parseInt"><a href="#parseInt" class="headerlink" title="parseInt()"></a>parseInt()</h4><p>用于将字符串转为整数。<br><a href="https://wangdoc.com/javascript/types/number.html#parseint" target="_blank" rel="noopener">详细用法</a></p><h4 id="parseFloat"><a href="#parseFloat" class="headerlink" title="parseFloat()"></a>parseFloat()</h4><p>parseFloat方法用于将一个字符串转为浮点数。<br><a href="https://wangdoc.com/javascript/types/number.html#parsefloat" target="_blank" rel="noopener">详细用法</a></p><h4 id="isNaN"><a href="#isNaN" class="headerlink" title="isNaN()"></a>isNaN()</h4><p>isNaN方法可以用来判断一个值是否为NaN。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(<span class="literal">NaN</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="number">123</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p><p>但是，isNaN只对数值有效，如果传入其他值，会被先转成数值。比如，传入字符串的时候，字符串会被先转成NaN，所以最后返回true，这一点要特别引起注意。也就是说，isNaN为true的值，有可能不是NaN，而是一个字符串。</p><p>出于同样的原因，对于对象和数组，isNaN也返回true。</p><p>但是，对于空数组和只有一个数值成员的数组，isNaN返回false。</p><p><a href="https://wangdoc.com/javascript/types/number.html#isnan" target="_blank" rel="noopener">详细用法</a></p><h4 id="isFinite"><a href="#isFinite" class="headerlink" title="isFinite()"></a>isFinite()</h4><p>isFinite方法返回一个布尔值，表示某个值是否为正常的数值。</p><p>除了Infinity、-Infinity、NaN和undefined这几个值会返回false，isFinite对于其他的数值都会返回true。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isFinite</span>(<span class="literal">Infinity</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isFinite</span>(-<span class="literal">Infinity</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isFinite</span>(<span class="literal">NaN</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isFinite</span>(<span class="literal">undefined</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isFinite</span>(<span class="literal">null</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isFinite</span>(<span class="number">-1</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>js的字符串可以放在单引号和双引号中</p><p>单引号字符串的内部，可以使用双引号。双引号字符串的内部，可以使用单引号。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'key = "value"'</span></span><br><span class="line"><span class="string">"It's a long journey"</span></span><br></pre></td></tr></table></figure><p>上面两个都是合法的字符串。</p><ul><li>如果要在单引号字符串的内部，使用单引号，就必须在内部的单引号前面加上反斜杠(<code>\</code>)，用来转义。</li><li>字符串默认只能写在一行内，分成多行将会报错。</li><li>如果长字符串必须分成多行，可以在每一行的尾部使用反斜杠。注意，反斜杠的后面必须是换行符，而不能有其他字符（比如空格），否则会报错。</li></ul><h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h3><p>需要用反斜杠转义的特殊字符，主要有下面这些。</p><ul><li><code>\0</code> ：null（\u0000）</li><li><code>\b</code> ：后退键（\u0008）</li><li><code>\f</code> ：换页符（\u000C）</li><li><code>\n</code> ：换行符（\u000A）</li><li><code>\r</code> ：回车键（\u000D）</li><li><code>\t</code> ：制表符（\u0009）</li><li><code>\v</code> ：垂直制表符（\u000B）</li><li><code>\&#39;</code> ：单引号（\u0027）</li><li><code>\&quot;</code> ：双引号（\u0022）</li><li><code>\\</code> ：反斜杠（\u005C）</li></ul><h3 id="字符串与数组"><a href="#字符串与数组" class="headerlink" title="字符串与数组"></a>字符串与数组</h3><p>字符串可以被视为字符数组，因此可以使用数组的方括号运算符，用来返回某个位置的字符（位置编号从0开始）。</p><p>但是，字符串与数组的相似性仅此而已。实际上，无法改变字符串之中的单个字符。</p><h3 id="length-属性"><a href="#length-属性" class="headerlink" title="length 属性"></a>length 属性</h3><p>length属性返回字符串的长度，该属性也是无法改变的。</p><h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><p>JavaScript 使用 Unicode 字符集。JavaScript 引擎内部，所有字符都用 Unicode 表示。<br><a href="https://wangdoc.com/javascript/types/string.html#%E5%AD%97%E7%AC%A6%E9%9B%86" target="_blank" rel="noopener">详细</a></p><h3 id="Base64转码"><a href="#Base64转码" class="headerlink" title="Base64转码"></a>Base64转码</h3><p>有时，文本里面包含一些不可打印的符号，比如 ASCII 码0到31的符号都无法打印出来，这时可以使用 Base64 编码，将它们转成可以打印的字符。另一个场景是，有时需要以文本格式传递二进制数据，那么也可以使用 Base64 编码。</p><p>所谓 Base64 就是一种编码方法，可以将任意值转成 0～9、A～Z、a-z、+和/这64个字符组成的可打印字符。使用它的主要目的，不是为了加密，而是为了不出现特殊字符，简化程序的处理。</p><p>两个 Base64 相关的方法。</p><ul><li>btoa()：任意值转为 Base64 编码</li><li>atob()：Base64 编码转为原来的值</li></ul><p>注意，这两个方法不适合非 ASCII 码的字符（如中文），会报错。</p><p>要将非 ASCII 码字符转为 Base64 编码，必须中间插入一个转码环节，再使用这两个方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b64Encode</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> btoa(<span class="built_in">encodeURIComponent</span>(str));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b64Decode</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">decodeURIComponent</span>(atob(str));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b64Encode(<span class="string">'你好'</span>) <span class="comment">// "JUU0JUJEJUEwJUU1JUE1JUJE"</span></span><br><span class="line">b64Decode(<span class="string">'JUU0JUJEJUEwJUU1JUE1JUJE'</span>) <span class="comment">// "你好"</span></span><br></pre></td></tr></table></figure><p><a href="https://segmentfault.com/a/1190000010433195" target="_blank" rel="noopener">有关URI编码的详解</a></p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><h4 id="生成方法"><a href="#生成方法" class="headerlink" title="生成方法"></a>生成方法</h4><p>简单说，对象就是一组“键值对”（key-value）的集合，是一种无序的复合数据集合。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  foo: <span class="string">'Hello'</span>,</span><br><span class="line">  bar: <span class="string">'World'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h4 id="键名"><a href="#键名" class="headerlink" title="键名"></a>键名</h4><ul><li>对象的所有键名都是字符串（ES6 又引入了 Symbol 值也可以作为键名），所以加不加引号都可以。</li><li>如果键名是数值，会被自动转为字符串。</li><li>如果键名不符合标识名的条件（比如第一个字符为数字，或者含有空格或运算符），且也不是数字，则必须加上引号，否则会报错。</li><li><p>对象的每一个键名又称为“属性”（property），它的“键值”可以是任何数据类型。如果一个属性的值为函数，通常把这个属性称为“方法”，它可以像函数那样调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  p: <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.p(<span class="number">1</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li><li><p>如果属性的值还是一个对象，就形成了链式引用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = &#123; <span class="attr">bar</span>: <span class="string">'hello'</span> &#125;;</span><br><span class="line"></span><br><span class="line">o1.foo = o2;</span><br><span class="line">o1.foo.bar <span class="comment">// "hello"</span></span><br></pre></td></tr></table></figure></li><li><p>就像上面那样，属性可以动态创建，不必在对象声明时就指定。</p></li></ul><h4 id="对象的引用"><a href="#对象的引用" class="headerlink" title="对象的引用"></a>对象的引用</h4><ul><li>如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有变量。</li></ul><h4 id="表达式还是语句？"><a href="#表达式还是语句？" class="headerlink" title="表达式还是语句？"></a>表达式还是语句？</h4><p>对象采用大括号表示，这导致了一个问题：如果行首是一个大括号，它到底是表达式还是语句？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">foo</span>: <span class="number">123</span> &#125;</span><br></pre></td></tr></table></figure><p>JavaScript 引擎读到上面这行代码，会发现可能有两种含义。第一种可能是，这是一个表达式，表示一个包含foo属性的对象；第二种可能是，这是一个语句，表示一个代码区块，里面有一个标签foo，指向表达式123。</p><p>为了避免这种歧义，V8 引擎规定，如果行首是大括号，一律解释为对象。不过，为了避免歧义，最好在大括号前加上圆括号。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&#123; <span class="attr">foo</span>: <span class="number">123</span>&#125;)</span><br></pre></td></tr></table></figure><h3 id="属性的操作"><a href="#属性的操作" class="headerlink" title="属性的操作"></a>属性的操作</h3><h4 id="属性的读取"><a href="#属性的读取" class="headerlink" title="属性的读取"></a>属性的读取</h4><p>读取对象的属性，有两种方法，一种是使用点运算符，还有一种是使用方括号运算符。</p><ul><li>请注意，如果使用方括号运算符，键名必须放在引号里面，否则会被当作变量处理。</li><li>数字键可以不加引号，因为会自动转成字符串。数值键名不能使用点运算符（因为会被当成小数点），只能使用方括号运算符。</li></ul><h4 id="属性的查看"><a href="#属性的查看" class="headerlink" title="属性的查看"></a>属性的查看</h4><p>查看一个对象本身的所有属性，可以使用<code>Object.keys</code>方法。</p><h4 id="属性的删除：delete-命令"><a href="#属性的删除：delete-命令" class="headerlink" title="属性的删除：delete 命令"></a>属性的删除：delete 命令</h4><p>delete命令用于删除对象的属性，删除成功后返回true。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">p</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.keys(obj) <span class="comment">// ["p"]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> obj.p <span class="comment">// true</span></span><br><span class="line">obj.p <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">Object</span>.keys(obj) <span class="comment">// []</span></span><br></pre></td></tr></table></figure></p><ul><li>注意，删除一个不存在的属性，delete不报错，而且返回true。</li><li>只有一种情况，delete命令会返回false，那就是该属性存在，且不得删除。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.defineProperty(&#123;&#125;, <span class="string">'p'</span>, &#123;</span><br><span class="line">  value: <span class="number">123</span>,</span><br><span class="line">  configurable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obj.p <span class="comment">// 123</span></span><br><span class="line"><span class="keyword">delete</span> obj.p <span class="comment">// false</span></span><br></pre></td></tr></table></figure><ul><li>另外，需要注意的是，delete命令只能删除对象本身的属性，无法删除继承的属性。</li></ul><h4 id="属性是否存在：in-运算符"><a href="#属性是否存在：in-运算符" class="headerlink" title="属性是否存在：in 运算符"></a>属性是否存在：in 运算符</h4><p>in运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值），如果包含就返回true，否则返回false。它的左边是一个字符串，表示属性名，右边是一个对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">p</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="string">'p'</span> <span class="keyword">in</span> obj <span class="comment">// true</span></span><br><span class="line"><span class="string">'toString'</span> <span class="keyword">in</span> obj <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><ul><li>in运算符的一个问题是，它不能识别哪些属性是对象自身的，哪些属性是继承的。这时，可以使用对象的hasOwnProperty方法判断一下，是否为对象自身的属性。</li></ul><h4 id="属性的遍历：for…in-循环"><a href="#属性的遍历：for…in-循环" class="headerlink" title="属性的遍历：for…in 循环"></a>属性的遍历：for…in 循环</h4><p>for…in循环用来遍历一个对象的全部属性。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'键名：'</span>, i);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'键值：'</span>, obj[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 键名： a</span></span><br><span class="line"><span class="comment">// 键值： 1</span></span><br><span class="line"><span class="comment">// 键名： b</span></span><br><span class="line"><span class="comment">// 键值： 2</span></span><br><span class="line"><span class="comment">// 键名： c</span></span><br><span class="line"><span class="comment">// 键值： 3</span></span><br></pre></td></tr></table></figure></p><p>for…in循环有两个使用注意点。</p><ul><li>它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性。</li><li>它不仅遍历对象自身的属性，还遍历继承的属性。</li></ul><h3 id="with语句"><a href="#with语句" class="headerlink" title="with语句"></a>with语句</h3><p>with语句的格式如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> (对象) &#123;</span><br><span class="line">  语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>它的作用是操作同一个对象的多个属性时，提供一些书写的方便。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  p1: <span class="number">1</span>,</span><br><span class="line">  p2: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">with</span> (obj) &#123;</span><br><span class="line">  p1 = <span class="number">4</span>;</span><br><span class="line">  p2 = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">obj.p1 = <span class="number">4</span>;</span><br><span class="line">obj.p2 = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="keyword">with</span> (<span class="built_in">document</span>.links[<span class="number">0</span>])&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(href);</span><br><span class="line">  <span class="built_in">console</span>.log(title);</span><br><span class="line">  <span class="built_in">console</span>.log(style);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.links[<span class="number">0</span>].href);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.links[<span class="number">0</span>].title);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.links[<span class="number">0</span>].style);</span><br></pre></td></tr></table></figure></p><ul><li>注意，如果with区块内部有变量的赋值操作，必须是当前对象已经存在的属性，否则会创造一个当前作用域的全局变量。</li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>作用域（scope）指的是变量存在的范围。在 ES5 的规范中，Javascript 只有两种作用域：一种是全局作用域，变量在整个程序中一直存在，所有地方都可以读取；另一种是函数作用域，变量只在函数内部存在。</p><p>ES6 又新增了块级作用域</p><ul><li>函数内部定义的变量，会在该作用域内覆盖同名全局变量。</li><li>注意，对于var命令来说，局部变量只能在函数内部声明，在其他区块中声明，一律都是全局变量。</li></ul><h4 id="函数内部的变量提升"><a href="#函数内部的变量提升" class="headerlink" title="函数内部的变量提升"></a>函数内部的变量提升</h4><p>与全局作用域一样，函数作用域内部也会产生“变量提升”现象.var命令声明的变量，不管在什么位置，变量声明都会被提升到函数体的头部。</p><h4 id="函数本身的作用域"><a href="#函数本身的作用域" class="headerlink" title="函数本身的作用域"></a>函数本身的作用域</h4><p>函数本身也是一个值，也有自己的作用域。它的作用域与变量一样，就是其声明时所在的作用域，与其运行时所在的作用域无关。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> x = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  x();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>上面代码中，函数x是在函数f的外部声明的，所以它的作用域绑定外层，内部变量a不会到函数f体内取值，所以输出1，而不是2。</p><p>总之，函数执行时所在的作用域，是定义时的作用域，而不是调用时所在的作用域。</p><p>同样的，函数体内部声明的函数，作用域绑定函数体内部。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> f = foo();</span><br><span class="line">f() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>上面代码中，函数foo内部声明了一个函数bar，bar的作用域绑定foo。当我们在foo外部取出bar执行时，变量x指向的是foo内部的x，而不是foo外部的x。正是这种机制，构成了下文要讲解的“闭包”现象。</p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><h4 id="参数的省略"><a href="#参数的省略" class="headerlink" title="参数的省略"></a>参数的省略</h4><ul><li>函数参数不是必需的，Javascript 允许省略参数，不会报错。</li><li>省略的参数的值就变为undefined。需要注意的是，函数的length属性与实际传入的参数个数无关，只反映函数预期传入的参数个数。</li></ul><p>但是，没有办法只省略靠前的参数，而保留靠后的参数。如果一定要省略靠前的参数，只有显式传入undefined。</p><h4 id="传递方式"><a href="#传递方式" class="headerlink" title="传递方式"></a>传递方式</h4><ul><li>函数参数如果是原始类型的值（数值、字符串、布尔值），传递方式是传值传递（passes by value）。这意味着，在函数体内修改参数值，不会影响到函数外部。</li><li>如果函数参数是复合类型的值（数组、对象、其他函数），传递方式是传址传递（pass by reference）。也就是说，传入函数的原始值的地址，因此在函数内部修改参数，将会影响到原始值。</li></ul><p>注意，如果函数内部修改的，不是参数对象的某个属性，而是替换掉整个参数，这时不会影响到原始值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  o = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">&#125;</span><br><span class="line">f(obj);</span><br><span class="line"></span><br><span class="line">obj <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure></p><p>上面代码中，在函数f内部，参数对象obj被整个替换成另一个值。这时不会影响到原始值。这是因为，形式参数（o）的值实际是参数obj的地址，重新对o赋值导致o指向另一个地址，保存在原地址上的值当然不受影响。</p><h4 id="同名参数"><a href="#同名参数" class="headerlink" title="同名参数"></a>同名参数</h4><p>如果有同名的参数，则取最后出现的那个值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a, a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>调用函数f的时候，没有提供第二个参数，a的取值就变成了undefined。这时，如果要获得第一个a的值，可以使用arguments对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a, a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p><h4 id="arguments-对象"><a href="#arguments-对象" class="headerlink" title="arguments 对象"></a>arguments 对象</h4><p>由于 JavaScript 允许函数有不定数目的参数，所以需要一种机制，可以在函数体内部读取所有参数。这就是arguments对象的由来。</p><p>arguments对象包含了函数运行时的所有参数，arguments[0]就是第一个参数，arguments[1]就是第二个参数，以此类推。这个对象只有在函数体内部，才可以使用。</p><ul><li><p>正常模式下，arguments对象可以在运行时修改。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">arguments</span>[<span class="number">0</span>] = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">arguments</span>[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>, <span class="number">1</span>) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure></li><li><p>严格模式下，arguments对象是一个只读对象，修改它是无效的，但不会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span>; <span class="comment">// 开启严格模式</span></span><br><span class="line">  <span class="built_in">arguments</span>[<span class="number">0</span>] = <span class="number">3</span>; <span class="comment">// 无效</span></span><br><span class="line">  <span class="built_in">arguments</span>[<span class="number">1</span>] = <span class="number">2</span>; <span class="comment">// 无效</span></span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>, <span class="number">1</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li></ul><p>上面代码中，函数体内是严格模式，这时修改arguments对象就是无效的。</p><p>通过arguments对象的length属性，可以判断函数调用时到底带几个参数。</p><h5 id="与数组的关系"><a href="#与数组的关系" class="headerlink" title="与数组的关系"></a>与数组的关系</h5><p>需要注意的是，虽然arguments很像数组，但它是一个对象。数组专有的方法（比如slice和forEach），不能在arguments对象上直接使用。</p><p>如果要让arguments对象使用数组方法，真正的解决方法是将arguments转为真正的数组。下面是两种常用的转换方法：slice方法和逐一填入新数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">var</span> args = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">  args.push(<span class="built_in">arguments</span>[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="callee-属性"><a href="#callee-属性" class="headerlink" title="callee 属性"></a>callee 属性</h5><p>arguments对象带有一个callee属性，返回它所对应的原函数。</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>前面提到，JavaScript 有两种作用域：全局作用域和函数作用域。函数内部可以直接读取全局变量。但是，函数外部无法读取函数内部声明的变量。</p><p>如果出于种种原因，需要得到函数内的局部变量。正常情况下，这是办不到的，只有通过变通方法才能实现。那就是在函数的内部，再定义一个函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> n = <span class="number">999</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">　　<span class="built_in">console</span>.log(n); <span class="comment">// 999</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然f2可以读取f1的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> n = <span class="number">999</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = f1();</span><br><span class="line">result(); <span class="comment">// 999</span></span><br></pre></td></tr></table></figure><p>上面代码中，函数f1的返回值就是函数f2，由于f2可以读取f1的内部变量，所以就可以在外部获得f1的内部变量了。</p><p>闭包就是函数f2，即能够读取其他函数内部变量的函数。由于在 JavaScript 语言中，只有函数内部的子函数才能读取内部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。</p><p>闭包最大的特点，就是它可以“记住”诞生的环境，比如f2记住了它诞生的环境f1，所以从f2可以得到f1的内部变量。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。</p><p>闭包的最大用处有两个</p><ul><li>一个是可以读取函数内部的变量</li><li>另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。<br>请看下面的例子，闭包使得内部变量记住上一次调用时的运算结果。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createIncrementor</span>(<span class="params">start</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> start++;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> inc = createIncrementor(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">inc() <span class="comment">// 5</span></span><br><span class="line">inc() <span class="comment">// 6</span></span><br><span class="line">inc() <span class="comment">// 7</span></span><br></pre></td></tr></table></figure></li></ul><p>为什么会这样呢？原因就在于inc始终在内存中，而inc的存在依赖于createIncrementor，因此也始终在内存中，不会在调用结束后，被垃圾回收机制回收。</p><ul><li>闭包的另一个用处，是封装对象的私有属性和私有方法。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _age;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">setAge</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    _age = n;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name: name,</span><br><span class="line">    getAge: getAge,</span><br><span class="line">    setAge: setAge</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = Person(<span class="string">'张三'</span>);</span><br><span class="line">p1.setAge(<span class="number">25</span>);</span><br><span class="line">p1.getAge() <span class="comment">// 25</span></span><br></pre></td></tr></table></figure></li></ul><p>上面代码中，函数Person的内部变量_age，通过闭包getAge和setAge，变成了返回对象p1的私有变量。</p><p>注意，外层函数每次运行，都会生成一个新的闭包，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大。因此不能滥用闭包，否则会造成网页的性能问题。</p><h3 id="立即调用的函数表达式（IIFE"><a href="#立即调用的函数表达式（IIFE" class="headerlink" title="立即调用的函数表达式（IIFE)"></a>立即调用的函数表达式（IIFE)</h3><p>在 Javascript 中，圆括号()是一种运算符，跟在函数名之后，表示调用该函数。比如，print()就表示调用print函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;());</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;)();</span><br></pre></td></tr></table></figure><p>这就叫做“立即调用的函数表达式”（Immediately-Invoked Function Expression）</p><p>上面两种写法都是以圆括号开头，引擎就会认为后面跟的是一个表示式，而不是函数定义语句.</p><p>通常情况下，只对匿名函数使用这种“立即执行的函数表达式”。它的目的有两个：一是不必为函数命名，避免了污染全局变量；二是 IIFE 内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">var</span> tmp = newData;</span><br><span class="line">processData(tmp);</span><br><span class="line">storeData(tmp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> tmp = newData;</span><br><span class="line">  processData(tmp);</span><br><span class="line">  storeData(tmp);</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure></p><p>上面代码中，写法二比写法一更好，因为完全避免了污染全局变量。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul><li>任何类型的数据，都可以放入数组。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [</span><br><span class="line">  &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;,</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="keyword">return</span> <span class="literal">true</span>;&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">arr[<span class="number">0</span>] <span class="comment">// Object &#123;a: 1&#125;</span></span><br><span class="line">arr[<span class="number">1</span>] <span class="comment">// [1, 2, 3]</span></span><br><span class="line">arr[<span class="number">2</span>] <span class="comment">// function ()&#123;return true;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><p>上面数组arr的3个成员依次是对象、数组、函数。</p><ul><li>如果数组的元素还是数组，就形成了多维数组。</li></ul><p>本质上，数组属于一种特殊的对象。typeof运算符会返回数组的类型是object。数组的特殊性体现在，它的键名是按次序排列的一组整数（0，1，2…）<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(arr)</span><br><span class="line"><span class="comment">// ["0", "1", "2"]</span></span><br></pre></td></tr></table></figure></p><ul><li>对象有两种读取成员的方法：点结构（object.key）和方括号结构（object[key]）。但是，对于数值的键名，不能使用点结构。</li></ul><h3 id="length属性"><a href="#length属性" class="headerlink" title="length属性"></a>length属性</h3><p>数组的length属性，返回数组的成员数量。</p><p>但需要注意的是，数组的数字键不需要连续，length属性的值总是比最大的那个整数键大1。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>];</span><br><span class="line">arr.length <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">arr[<span class="number">2</span>] = <span class="string">'c'</span>;</span><br><span class="line">arr.length <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">arr[<span class="number">9</span>] = <span class="string">'d'</span>;</span><br><span class="line">arr.length <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">arr[<span class="number">1000</span>] = <span class="string">'e'</span>;</span><br><span class="line">arr.length <span class="comment">// 1001</span></span><br></pre></td></tr></table></figure></p><p>length属性是可写的。如果人为设置一个小于当前成员个数的值，该数组的成员会自动减少到length设置的值。清空数组的一个有效方法，就是将length属性设为0。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [ <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span> ];</span><br><span class="line">arr.length <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">arr.length = <span class="number">2</span>;</span><br><span class="line">arr <span class="comment">// ["a", "b"]</span></span><br></pre></td></tr></table></figure><h3 id="in运算符"><a href="#in运算符" class="headerlink" title="in运算符"></a>in运算符</h3><p>检查某个键名是否存在的运算符in，适用于对象，也适用于数组。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [ <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span> ];</span><br><span class="line"><span class="number">2</span> <span class="keyword">in</span> arr  <span class="comment">// true</span></span><br><span class="line"><span class="string">'2'</span> <span class="keyword">in</span> arr <span class="comment">// true</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">in</span> arr <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p><h3 id="for…in-循环和数组的遍历"><a href="#for…in-循环和数组的遍历" class="headerlink" title="for…in 循环和数组的遍历"></a>for…in 循环和数组的遍历</h3><p>for…in循环不仅可以遍历对象，也可以遍历数组，毕竟数组只是一种特殊对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> a) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p><p>但是，for…in不仅会遍历数组所有的数字键，还会遍历非数字键。</p><p>所以，不推荐使用for…in遍历数组。数组的遍历可以考虑使用for循环或while循环。</p><p>数组的forEach方法，也可以用来遍历数组，详见《标准库》的 Array 对象一章</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>];</span><br><span class="line">colors.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">color</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(color);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="comment">// blue</span></span><br></pre></td></tr></table></figure><h3 id="空位"><a href="#空位" class="headerlink" title="空位"></a>空位</h3><p>length属性不过滤空位。所以，使用length属性进行数组遍历，一定要非常小心。</p><p>数组的某个位置是空位，与某个位置是undefined，是不一样的。如果是空位，使用数组的forEach方法、for…in结构、以及Object.keys方法进行遍历，空位都会被跳过。</p><p>这就是说，空位就是数组没有这个元素，所以不会被遍历到，而undefined则表示数组有这个元素，值是undefined，所以遍历不会跳过。</p><h3 id="类似数组的对象"><a href="#类似数组的对象" class="headerlink" title="类似数组的对象"></a>类似数组的对象</h3><p>数组的slice方法可以将“类似数组的对象”变成真正的数组。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="built_in">Array</span>.prototype.slice.call(arrayLike);</span><br></pre></td></tr></table></figure></p><p>“类似数组的对象”还有一个办法可以使用数组的方法，就是通过call()把数组的方法放到对象上面。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">value, index</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index + <span class="string">' : '</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.forEach.call(arrayLike, print);</span><br></pre></td></tr></table></figure><p>上面代码中，arrayLike代表一个类似数组的对象，本来是不可以使用数组的forEach()方法的，但是通过call()，可以把forEach()嫁接到arrayLike上面调用。</p><p>下面的例子就是通过这种方法，在arguments对象上面调用forEach方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// forEach 方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logArgs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Array</span>.prototype.forEach.call(<span class="built_in">arguments</span>, <span class="function"><span class="keyword">function</span> (<span class="params">elem, i</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i + <span class="string">'. '</span> + elem);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于 for 循环</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logArgs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i + <span class="string">'. '</span> + <span class="built_in">arguments</span>[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>字符串也是类似数组的对象，所以也可以用Array.prototype.forEach.call遍历。</p><p>注意，这种方法比直接使用数组原生的forEach要慢，所以最好还是先将“类似数组的对象”转为真正的数组，然后再直接调用数组的forEach方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//call</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.forEach.call(<span class="string">'abc'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chr</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(chr);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//slice</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="built_in">Array</span>.prototype.slice.call(<span class="string">'abc'</span>);</span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">chr</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(chr);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近准备系统性的过一遍阮一峰的JavaScript教程，因为看的比较快速所以可能只能在这里简略的记录一些关键的地方了，希望这次能对JS的认识更全面一些吧。哈哈加油！那么下面开始咯。&lt;/p&gt;
&lt;p&gt;总结自&lt;a href=&quot;https://wangdoc.com/javascr
      
    
    </summary>
    
      <category term="学习笔记" scheme="https://minoyu.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JavaScript" scheme="https://minoyu.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JavaScript/"/>
    
    
      <category term="《JavaScript 标准参考教程-阮一峰》" scheme="https://minoyu.github.io/tags/%E3%80%8AJavaScript-%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B-%E9%98%AE%E4%B8%80%E5%B3%B0%E3%80%8B/"/>
    
      <category term="学习笔记" scheme="https://minoyu.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Core Java Day5--基本编程结构5(数组与数组列表、方法)</title>
    <link href="https://minoyu.github.io/2018/10/28/Core-Java-Day5-%E5%9F%BA%E6%9C%AC%E7%BC%96%E7%A8%8B%E7%BB%93%E6%9E%845/"/>
    <id>https://minoyu.github.io/2018/10/28/Core-Java-Day5-基本编程结构5/</id>
    <published>2018-10-28T13:52:45.000Z</published>
    <updated>2019-01-23T12:51:49.730Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-8-数组与数组列表"><a href="#1-8-数组与数组列表" class="headerlink" title="1.8 数组与数组列表"></a>1.8 数组与数组列表</h2><p>数组是收集相同类型多个元素的基本编程结构。</p><p>Java内置了数组类型，并且也提供根据需求随时增长或缩减的ArrayList类。</p><p>ArrayList是集合框架中的一部分，在这本书的后面会有讲到</p><h3 id="使用数组"><a href="#使用数组" class="headerlink" title="使用数组"></a>使用数组</h3><p>对所有的类型都有相应的数组类型，例如<code>int[]</code>,<code>String[]</code>.</p><p>和Ｃ语言的数组不太相同，java中的声明方式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组变量的声明</span></span><br><span class="line">String[] names;</span><br><span class="line"><span class="comment">//变量的初始化，我们用一个新的数组去初始化它。因此我们用到new 操作符</span></span><br><span class="line">names = <span class="keyword">new</span> String[<span class="number">100</span>];</span><br><span class="line"><span class="comment">//声明和初始化可以放在一起</span></span><br><span class="line">String[] names　= <span class="keyword">new</span> String[<span class="number">100</span>];</span><br><span class="line"><span class="comment">//现在names引用一个有100个元素的数组了，合法下标范围0~99</span></span><br></pre></td></tr></table></figure></p><p>使用C语言中的语法来声明数组变量(int nums[])也是合法的，但不够清晰，Java中一般不用这种方式。</p><ul><li>如果下标越界，会抛出<code>ArrayIndexOutOfBoundException</code>异常</li></ul><p>可以用 数组名.length 获得数组的长度(个数，如上面的100)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用空字符串填充数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;names.length;i++)&#123;</span><br><span class="line">    names[i]=<span class="string">""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="构造数组"><a href="#构造数组" class="headerlink" title="构造数组"></a>构造数组</h3><p>当你使用操作符new构造数组时，会用默认值填充数组</p><ul><li>数字类型 (包括char类型)的数组用0填充</li><li>Boolean类型的数组用false填充</li><li>对象数组用空引用填充</li></ul><p>警告：任何时候，当构造对象数组时，需要使用对象填充数组。考虑这种声明<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BigInteger[] numbers = <span class="keyword">new</span> BigInteger[<span class="number">100</span>];</span><br><span class="line"><span class="comment">//此刻 你还没有任何BigInteger 仅是一个100个空引用的数组。</span></span><br><span class="line"><span class="comment">//你需要用BigInteger对象的引用代替他们</span></span><br></pre></td></tr></table></figure></p><p>你可以写个循环用值填充数组，你也可以将他们列在括号中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] primes = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>&#125;</span><br><span class="line"><span class="comment">//不用使用new操作符，不用指定数组长度</span></span><br><span class="line"><span class="comment">//如果你不想给数组名称，则可以使用类似的语法，给已存在的数组变量赋值</span></span><br><span class="line">primes = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>&#125;</span><br></pre></td></tr></table></figure></p><p>注意，允许数组长度为0，但长度为0的数组与null不同，与之前的空字符串与null不同类似。</p><h3 id="数组列表"><a href="#数组列表" class="headerlink" title="数组列表"></a>数组列表</h3><p>构造数组时，你需要知道数组的长度。一旦构造后，数组的长度不能改变。</p><p>解决这种问题的方法就是使用java,util包中的ArrayList类。ArrayList对象内部管理数组。</p><p>当数组太小或者不够使用时，自动创建好另外一个内部数组，并且将元素移动到该数组。这个过程对使用数组列表的程序员是不可见。</p><p>数组和数组列表的语法完全不同，在数组中使用特殊的语法————[]操作符访问元素，使用Type[]语法获取数组类型，使用new Type[n]语法构造数组。相比之下，数组列表类，你可以使用构造实例和调用的语法。</p><p>ArraryList类是泛型类，这是一种带有类型参数的类。在这本书的后面会讲到。</p><p>使用泛型类语法，在尖括号中指定类型，声明一个数组列表变量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; friends;</span><br><span class="line"><span class="comment">//上面只是声明了变量。你现在需要构建数组列表：</span></span><br><span class="line">friends = <span class="keyword">new</span> ArrayList&lt;&gt;;</span><br><span class="line">    <span class="comment">//或者new ArrayList&lt;String&gt;()</span></span><br></pre></td></tr></table></figure></p><p>注意空的&lt;&gt; ，编译器会从变量的声明推断出类型参数（被称为钻石语法）</p><p>该调用中没有构造参数，但依然必须在末尾提供()。<br>结果为一个大小为0的数组列表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以通过add方法给末尾添加元素。</span></span><br><span class="line">friends.add(<span class="string">"Peter"</span>);</span><br><span class="line">friends.add(<span class="string">"Mino"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以在列表的任何位置添加或删除元素</span></span><br><span class="line">freinds.remove(<span class="number">1</span>);</span><br><span class="line">friends.add(<span class="number">0</span>,<span class="string">"Paul"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//需要使用方法调用访问元素，get方法读取元素，set方法将元素</span></span><br><span class="line"><span class="comment">//用另外一个代替：</span></span><br><span class="line">String first = friends.get(<span class="number">0</span>);</span><br><span class="line">friends.set(<span class="number">1</span>,<span class="string">"Mary"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//size方法返回列表当前的大小。</span></span><br><span class="line"><span class="comment">//可以使用下面的循环遍历数组列表中的所有元素。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;friends.size();i++)&#123;</span><br><span class="line">    System.out.println(friends.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基本类型包装类"><a href="#基本类型包装类" class="headerlink" title="基本类型包装类"></a>基本类型包装类</h3><p>！你不能使用基本类型作为类型参数，例如ArrayList<int>是非法的。你必须使用包装类。</int></p><p>每一种基本类型，都有对应的包装类，Integer、Byte、Short、Long、Character、Float、Double和Boolean。</p><p>所以刚才那种要收集整数的数组列表可以写成<code>ArrayList&lt;Integer&gt;</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; numbers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">numbers.add(<span class="number">42</span>);</span><br><span class="line"><span class="keyword">int</span> first = numbers.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>基本类型和他们对应的包装类之间的转换是自动进行的。</p><ul><li>在调用add方法时，一个值为42的Integer类对象在一种被称为自动装箱的过程中自动构造了。</li><li>在代码的最后一行，get调用返回一个Integer对象，在变量赋值之前自动拆箱，内部产生一个int值</li></ul><p>像字符串一样，比较两个包装类是否相等时不可使用==和!= 记得调用包装类的equals方法</p><h3 id="增强for循环"><a href="#增强for循环" class="headerlink" title="增强for循环"></a>增强for循环</h3><p>你可能想经常遍历数组的所有元素，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;numbers.length;i++)&#123;</span><br><span class="line">    sum += numbers[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//还有种更普遍的方式，成为增强循环</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n :numbers)&#123;</span><br><span class="line">    sum +=n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//变量n被复制为每次的循环项</span></span><br></pre></td></tr></table></figure></p><h3 id="数组与数组列表的复制"><a href="#数组与数组列表的复制" class="headerlink" title="数组与数组列表的复制"></a>数组与数组列表的复制</h3><p>你可以将数组变量复制到另外一个数组变量，但是那样两个变量引用同一个数组（共享的数组）,可以理解为数组变量保存的是一个地址，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] numbers = primes;</span><br><span class="line">numbers[<span class="number">5</span>] = <span class="number">42</span>;</span><br><span class="line"><span class="comment">//数组列表引用的也是同样的工作方式</span></span><br><span class="line">ArrayList&lt;String&gt; people = friends;</span><br><span class="line">people.set(<span class="number">0</span>,<span class="string">"Merry"</span>);</span><br><span class="line"><span class="comment">//于是现在friends中的第一个元素也是Merry</span></span><br></pre></td></tr></table></figure></p><p>如果你不想要这种共享数组，则需要复制数组，可以使用静态方法Array.copyOf(被复制的数组，被复制的数组长度)。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] copiedPrimes = Arrays.copyOf(primes,primes.length);</span><br><span class="line"><span class="comment">//该方法会构造一个新数组，并将原数组的元素复制进去</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对于数组列表，可直接从已存在的数组列表构造一个新的数组列表</span></span><br><span class="line">ArrayList&lt;String&gt; copiedFriends = <span class="keyword">new</span> ArrayList&lt;&gt;(friends);</span><br></pre></td></tr></table></figure></p><ul><li><p>构造函数也可以将数组复制到数组列表，首先使用Arrays.asList方法，将数组包装到列表中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; copiedFriends = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(names));</span><br></pre></td></tr></table></figure></li><li><p>Arrays.asList可以接受一个数组或任意数量的参数。</p></li><li>使用任意变量的参数时可以将它当做数组初始化语法的一种替代<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Arrays.asList(names);</span><br><span class="line">Arrays.asList(<span class="string">"Mino"</span>,<span class="string">"Paul"</span>,<span class="string">"Mary"</span>);</span><br></pre></td></tr></table></figure></li></ul><p>也可以将数组列表复制到数组中，必须提供正确类型的数组<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[] names = friends.toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure></p><p>没有一种容易的方式可以完成基本类型数组和对应的包装类数组列表之间转换。例如：要在<code>int[]</code>和<code>ArrayList&lt;Integer&gt;</code>之间转换，你需要循环或者IntStream(这本书之后会讲到)。</p><h3 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h3><p>Arrays（数组）类和Collection（集合）类实现了数组和数组列表的常用方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fill方法，填充数组或数组列表</span></span><br><span class="line">Arrays.fill(numbers,<span class="number">0</span>);<span class="comment">//int[]数组</span></span><br><span class="line">Collections.fill(friends,<span class="string">""</span>)<span class="comment">//ArrayList&lt;String&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//sort 方法 排个序</span></span><br><span class="line">Arrays.sort(numbers);</span><br><span class="line">Collections.sort(friends);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Array.toString方法产生一个数组的字符串表示。</span></span><br><span class="line"><span class="comment">//调试时要输出数组该方法特别管用</span></span><br><span class="line">System.out.pintln(Arrays.toString(nums));</span><br><span class="line"><span class="comment">//数组列表对象也有个toString方法</span></span><br><span class="line">friends.toString();</span><br><span class="line"><span class="comment">//PS. println方法输出时会自动调用toString()方法</span></span><br><span class="line">System.out.println(friends);</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组列表还有一对有用的方法，数组没有对应的方法</span></span><br><span class="line">Collections.reverse(names);<span class="comment">//反转元素</span></span><br><span class="line">Collections.shuffle(names);<span class="comment">//随机打乱元素</span></span><br></pre></td></tr></table></figure></p><h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><p>所有java程序的main方法都有一个字符串数组的参数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//当程序执行时 在命令行中指定的参数就复制给args</span><br><span class="line">//如果程序在命令行中以如下方式调用</span><br><span class="line">java Greeting hello world</span><br><span class="line">//Greeting是类名 而后面的参数以空格分割开。</span><br><span class="line">//所以args[0]为<span class="string">"hello"</span> args[1]为<span class="string">"world"</span></span><br></pre></td></tr></table></figure><h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p>Java没有真实的多维数组，对维数组是通过数组的数组来实现的。例如 声明一个对维数组：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] square = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,</span><br><span class="line">    &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,</span><br><span class="line">    &#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,</span><br><span class="line">    &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>从技术上来看 这是一个一维的int[]数组，要访问元素，使用两个中括号。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> element = square[<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line"><span class="comment">//第一个索引选择行数组square[1]</span></span><br><span class="line"><span class="comment">//第二个索引从该行数组获得元素</span></span><br></pre></td></tr></table></figure></p><p>可以互相换行<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] temp = square[<span class="number">0</span>];</span><br><span class="line">square[<span class="number">0</span>]=square[<span class="number">1</span>];</span><br><span class="line">square[<span class="number">1</span>]=temp;</span><br></pre></td></tr></table></figure></p><p>如果你不提供初始值，则必须使用new操作符并指定行数和列数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] square =<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>][<span class="number">4</span>];<span class="comment">//行在前列在后。</span></span><br></pre></td></tr></table></figure></p><ul><li>二维数组的实际实现就是，数组的每一行是用数组填充的。并不要求数组的每一行长度相同。</li><li>遍历二位数组需要使用两个循环，一个行循环，一个列循环。</li><li>对于二维数组，有方法<code>Arrays.deepToString(array)</code>.</li><li>没有二维的数组列表，但是可以声明ArrayList&lt;ArrayList<integer>&gt;类型的变量并自己构建行。</integer></li></ul><h2 id="1-9-功能分解"><a href="#1-9-功能分解" class="headerlink" title="1.9 功能分解"></a>1.9 功能分解</h2><p>如果你的main方法太长了，则可以将程序分解到多个类中。对于一个简单的程序，可以将程序代码分解到同一个类的方法中。这些方法都必须以static修饰符声明，如同main一样。本书的第二章会介绍。</p><h3 id="静态方法的声明与调用"><a href="#静态方法的声明与调用" class="headerlink" title="静态方法的声明与调用"></a>静态方法的声明与调用</h3><p>声明方法时，在方法头提供返回值类型、方法名称以及参数名称。然后在方法体提供方法的实现。return返回结果。</p><p>例如如下的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">average</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">double</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> sum = x + y;</span><br><span class="line">    <span class="keyword">return</span> sum/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该方法与main在同一个类中，可以直接调用</span></span><br><span class="line"><span class="comment">//java中与出现的前后顺序没有关系</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a = ...;</span><br><span class="line">    <span class="keyword">double</span> b = ...;</span><br><span class="line">    <span class="keyword">double</span> average = average(a,b);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="数组参数与返回值"><a href="#数组参数与返回值" class="headerlink" title="数组参数与返回值"></a>数组参数与返回值</h3><p>可以将数组传递给方法，方法只是收到数组的引用，通过引用可以修改原数组。</p><p>例如下面这个例子交换数组的两个元素<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] values,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = values[i];</span><br><span class="line">    values[i] = values[j];</span><br><span class="line">    values[j] = temp</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此方法直接对数组进行修改 不需要返回值</span></span><br></pre></td></tr></table></figure></p><p>方法可以返回数组。下面这个方法返回一个数组，返回的数组是生产的一个新数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] firstLast(<span class="keyword">int</span>[] values)&#123;</span><br><span class="line">    <span class="keyword">if</span> (values.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;values[<span class="number">0</span>],values[values.length-<span class="number">1</span>]&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>如printf这样的方法，允许调用者提供数量可变的参数<br>例如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.printf(<span class="string">"%d"</span>, n);</span><br><span class="line"><span class="comment">//与</span></span><br><span class="line">System.out.printf(<span class="string">"%d %s"</span>,n,<span class="string">"Hello"</span>);</span><br></pre></td></tr></table></figure></p><p>虽然他们调用同样的方法，但是参数个数不同。</p><p>我们定义一个average方法，在类型之后加上<code>...</code>声明变长参数，这样我们就可以以任意参数长度调用average。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">average</span><span class="params">(<span class="keyword">double</span>... values)</span></span></span><br></pre></td></tr></table></figure></p><p>参数实际上是double类型的数组。当方法被调用时，创建了一个数组并且以参数填充该数组。在方法体中，可以像数组一样使用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">average</span><span class="params">(<span class="keyword">double</span>... values)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">double</span> v : values) sum += v;</span><br><span class="line">    <span class="keyword">return</span> values.length == <span class="number">0</span> ? <span class="number">0</span> :sum / values.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>注意 可变参数必须是方法的最后一个参数，例如<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">max</span><span class="params">(<span class="keyword">double</span> first,<span class="keyword">double</span>... rest)</span></span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-8-数组与数组列表&quot;&gt;&lt;a href=&quot;#1-8-数组与数组列表&quot; class=&quot;headerlink&quot; title=&quot;1.8 数组与数组列表&quot;&gt;&lt;/a&gt;1.8 数组与数组列表&lt;/h2&gt;&lt;p&gt;数组是收集相同类型多个元素的基本编程结构。&lt;/p&gt;
&lt;p&gt;Java内
      
    
    </summary>
    
      <category term="学习笔记" scheme="https://minoyu.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java" scheme="https://minoyu.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/"/>
    
    
      <category term="学习笔记" scheme="https://minoyu.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《Java核心技术》" scheme="https://minoyu.github.io/tags/%E3%80%8AJava%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Core Java Day4--基本编程结构4(输入与输出、控制流)</title>
    <link href="https://minoyu.github.io/2018/10/25/Core-Java-Day4-%E5%9F%BA%E6%9C%AC%E7%BC%96%E7%A8%8B%E7%BB%93%E6%9E%844/"/>
    <id>https://minoyu.github.io/2018/10/25/Core-Java-Day4-基本编程结构4/</id>
    <published>2018-10-25T08:48:12.000Z</published>
    <updated>2019-01-23T12:51:49.729Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-6输入与输出"><a href="#1-6输入与输出" class="headerlink" title="1.6输入与输出"></a>1.6输入与输出</h2><h3 id="读取输入"><a href="#读取输入" class="headerlink" title="读取输入"></a>读取输入</h3><p>调用<code>System.out.println</code>时，输出发送到“标准输出流”，然后在窗口上显示出来。</p><p>但从“标准输入流”读取不是那么简单，因为相应的<code>System.in</code>对象只有读取单个字节的方法。要想读取字符串和数字，需要构造一个Scanner对象依附到<code>System.in</code></p><p><code>Scanner</code>类位于<code>java.util</code>包中，使用前要在程序的开始位置<code>import</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line">Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="comment">//nextLine方法从输入读取一行</span></span><br><span class="line">System.out.println(<span class="string">"What's your name?"</span>);</span><br><span class="line">String name = in.nextLine();</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里nextLine是合理的，因为名字可能会有姓名分割。</span></span><br><span class="line"><span class="comment">//如果要读取用空格分割的单个单词，使用next</span></span><br><span class="line">String firstName = in.next();</span><br><span class="line"></span><br><span class="line"><span class="comment">//整数和浮点数　可以使用</span></span><br><span class="line">String age = in.nextInt();</span><br><span class="line">String score = in.nextDouble();</span><br><span class="line"></span><br><span class="line"><span class="comment">//还有一些判断方法</span></span><br><span class="line">in.hasNextLine();</span><br><span class="line">in.hasNext();</span><br><span class="line">in.hasNextInt();</span><br><span class="line">in.hasNextDouble();</span><br><span class="line"><span class="comment">//可以在读取前判断一下，例如</span></span><br><span class="line"><span class="keyword">if</span>(in.hasNextInt())&#123;</span><br><span class="line">    <span class="keyword">int</span> age = in.nextInt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在终端读取密码"><a href="#在终端读取密码" class="headerlink" title="在终端读取密码"></a>在终端读取密码</h4><p>读取密码时可以使用<code>Console</code>类来代替因为<code>Scanner</code>是可见的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Console terminal = System.console();</span><br><span class="line">String username = terminal.readLIne(<span class="string">"User name: "</span>);</span><br><span class="line"><span class="keyword">char</span>[] passwd = terminal.readPassword(<span class="string">"Password:"</span>)</span><br></pre></td></tr></table></figure></p><p>密码以一组字符串数组的形式返回。与将密码存在字符串中相比更加的安全，因为在完成必要的工作后，数组可以重写而字符串不能更改。</p><h3 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h3><ul><li><code>println</code>新起一行，所有数字都会显示</li><li><code>print</code>不会新起一行，所有数字都会显示</li><li><code>printf</code>格式输出方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">System.out.print(<span class="number">1000.0</span>/<span class="number">3.0</span>);</span><br><span class="line"><span class="comment">//333.333333333333</span></span><br><span class="line">System.out.printf(<span class="string">"%8.2f"</span>,<span class="number">1000.0</span>/<span class="number">3.0</span>);</span><br><span class="line"><span class="comment">//浮点数宽度为８（包括小数点），精度为小数点后两位</span></span><br><span class="line"><span class="comment">//□□333.33</span></span><br></pre></td></tr></table></figure></li></ul><p>以%开头的每一个格式说明符都会被相应的参数替代，转换字符说明了要被格式化的值所属的类型</p><p>printf的使用方法和Ｃ很相似。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.printf(<span class="string">"%s,%d"</span>,name,age)</span><br></pre></td></tr></table></figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/core_java_post/day4-1.jpg" alt="格式化输出的转换字符" title="">                </div>                <div class="image-caption">格式化输出的转换字符</div>            </figure><p>此外，还可以指定一些标记符控制格式化输出的显示形式</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/core_java_post/day4-2.jpg" alt="格式化输出的标记符" title="">                </div>                <div class="image-caption">格式化输出的标记符</div>            </figure><p>例如，为一个浮点数添加分组标记符和正负标记符<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.printf(<span class="string">"%f"</span>,<span class="number">100000.0</span>/<span class="number">3.0</span>);</span><br><span class="line"><span class="comment">//+33,333.33</span></span><br></pre></td></tr></table></figure></p><p>你也可以使用<code>String.format</code>方法来创建不打印输出的格式化字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String message = String.format(<span class="string">"%s,%d"</span>,name,age)</span><br></pre></td></tr></table></figure><h2 id="1-7控制流"><a href="#1-7控制流" class="headerlink" title="1.7控制流"></a>1.7控制流</h2><p>Java的控制流声明与其他语言非常的相似，这里我可能会略过一些相似的内容。</p><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>像<code>if</code>/<code>else</code>/<code>switch</code>等的分支结构我们已经非常熟悉</p><p>需要注意的是不要忘记在想要结束的分支末尾添加break.</p><p>在java中，case可以使用以下任何类型的类型值</p><ul><li>char,byte,short或int类型的常量表达式(或者这些类型的包装类)</li><li>文字串</li><li>枚举类型值（第四章）</li></ul><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p><code>while</code>/<code>do while</code>/<code>for</code></p><p>在for语句中如果省略了条件，则默认为总是真。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;)</span><br><span class="line"><span class="comment">//无限循环</span></span><br></pre></td></tr></table></figure></p><p>Java中有一种增强的for循环，使针对数组或集合的for循环的写法更加方便，之后将在数组中讲到。</p><h4 id="跳出循环和继续循环"><a href="#跳出循环和继续循环" class="headerlink" title="跳出循环和继续循环"></a>跳出循环和继续循环</h4><ul><li>break 退出循环</li><li>continue 跳到下一次循环</li></ul><p>可以在应该退出的声明前加上标签，为break提供标签，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">outer:</span><br><span class="line"><span class="keyword">while</span>()&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span>()&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span>(...) <span class="keyword">break</span> outer;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//带标签的break跳转到这里</span></span><br></pre></td></tr></table></figure></p><p>注意：你在声明的顶部加标签，但是break声明跳到尾部。<br>普通的break只能用来退出循环或switch，但是带标签的break可以将控制转移到任何声明的结束，甚至是一个声明块。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">exit:&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span>(...) <span class="keyword">break</span> exit;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//带标签的break跳转到这里</span></span><br></pre></td></tr></table></figure></p><p>continue声明也可以带标签，它可以跳转到标签循环的下一个迭代。</p><p>!!!过多的break和continue会让程序变得难以阅读，晕头转向，你完全可以选择没有他们的编程方式</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-6输入与输出&quot;&gt;&lt;a href=&quot;#1-6输入与输出&quot; class=&quot;headerlink&quot; title=&quot;1.6输入与输出&quot;&gt;&lt;/a&gt;1.6输入与输出&lt;/h2&gt;&lt;h3 id=&quot;读取输入&quot;&gt;&lt;a href=&quot;#读取输入&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="学习笔记" scheme="https://minoyu.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java" scheme="https://minoyu.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/"/>
    
    
      <category term="学习笔记" scheme="https://minoyu.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《Java核心技术》" scheme="https://minoyu.github.io/tags/%E3%80%8AJava%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Core Java Day 3--基本编程结构3(操作运算、字符串)</title>
    <link href="https://minoyu.github.io/2018/10/22/Core-Java-Day-3-%E5%9F%BA%E6%9C%AC%E7%BC%96%E7%A8%8B%E7%BB%93%E6%9E%84-3/"/>
    <id>https://minoyu.github.io/2018/10/22/Core-Java-Day-3-基本编程结构-3/</id>
    <published>2018-10-22T15:06:11.000Z</published>
    <updated>2019-01-23T12:51:49.728Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-4-操作运算"><a href="#1-4-操作运算" class="headerlink" title="1.4 操作运算"></a>1.4 操作运算</h2><p>Java 与基于Ｃ语言的所有语言使用相似的操作符，接下来我来找一些在java需要注意的地方。</p><h3 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h3><ul><li>要格外小心<code>/</code>操作符，如果两个操作数都是整数，它代表整数。如果有一个操作数为小数则输出结果为浮点型。（类型的自动转换）。</li><li>整数除以０会导致异常，浮点数除以０会产生无限值或NaN,不会产生异常。</li><li>若ｎ为奇数，当ｎ为正数时，<code>n%2</code> 的值为１； 当ｎ为负数时，<code>n%2</code>的值为－１。实际中处理负数是不幸的。当操作数可能为负数时，切记小心使用％。可以考虑使用Math.floorMod方法。</li></ul><h3 id="数学方法"><a href="#数学方法" class="headerlink" title="数学方法"></a>数学方法</h3><p>举个例子，没有操作符可以产生次方，但是你可以调用Math.pow方法，<code>Math.pow(x,y)</code>会产生ｘ的ｙ次方。</p><p>静态方法不用在对象上调用。像静态常量一样，你只需要在前面加上声明该静态方法/变量的类名</p><p>类似的方法还有<code>Math.sqrt</code>/<code>Math.min</code>/<code>Math.max</code>等</p><p>此外Math类中提供三角函数和对数方法，以及常量<code>Math.PI</code>和<code>Math.E</code>。</p><ul><li>Math类中提供一些可以让整数运算更安全的方法，你可以捕获异常或终止程序，而不会是像普通的数学运算符那样使程序以错误的结果默默继续运行。</li></ul><h3 id="数字类型的转换"><a href="#数字类型的转换" class="headerlink" title="数字类型的转换"></a>数字类型的转换</h3><p>在Java中，如果没有信息损失，转换总是合法的。</p><ul><li>从byte类型　到　short、int、long或double</li><li>从short和char类型　到　int、long或double</li><li>从int类型到long、double</li><li>从整型到浮点型总是合法的</li></ul><p>==需要注意的是　下面的转换是合法的，但是他们损失了信息==</p><ul><li>从int到float</li><li>从long到float或double。</li></ul><p>如果转换不允许，可以使用cast运算符（将目标类型写在括号中）来强制转换，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> x = <span class="number">3.75</span>;</span><br><span class="line"><span class="keyword">int</span> n =(<span class="keyword">int</span>)x;</span><br><span class="line"><span class="comment">//这种情况下，就丢弃了小数部分，将ｎh设置为了3.</span></span><br></pre></td></tr></table></figure><p>如果你想获得四舍五入后的整数而不是直接丢弃小数，你可以使用Math.round(x)。</p><p>==当使用cast方式强制转换数据时，需要格外注意。==<br>如果你收到了警告，cast转换会悄悄地丢弃掉数字的部分数据，你可以使用Math.toIntExact方法代替，当无法转换时会抛出异常。</p><h3 id="大数"><a href="#大数" class="headerlink" title="大数"></a>大数</h3><p>如果基本的整数类型和浮点类型精确度还不够满足需求，你可以使用java.math包中的BigInteger和BigDecimal类。这些类的对象代表了数字，该数字有任意长序列的位数。他们实现了对任意精度整数/浮点数的计算。</p><p>BigInteger类的静态方法valueOf讲long型转换为BigInteger<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BigInteger n = BigInteger.valueOf(<span class="number">124135431242L</span>);</span><br></pre></td></tr></table></figure></p><p>你也可以使用数字字符串构造BigInteger:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BigInteger m = <span class="keyword">new</span> BigInteger(<span class="string">"124135431242"</span>);</span><br></pre></td></tr></table></figure></p><p>Java不允许对象使用操作符，因此操作大数时，必须使用方法调用。例如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BigInteger o = BigInteger.valueOf(<span class="number">5</span>).multiply(n.add(m))</span><br><span class="line"><span class="comment">//5*(n+m)</span></span><br></pre></td></tr></table></figure></p><p>记得在之前我们遇到的,使用浮点类型2.0-1.1的结果为0.99999999…吗,在这里我们使用BigDecimal可以计算出准确结果。<br>BigDecimal.valueOf(n,e) 返回BigDecimal实例，其值为ｎ×10的-e次方<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal.valueOf(<span class="number">2</span>,<span class="number">0</span>).substract(BigDecimal.valueOf(<span class="number">11</span>,<span class="number">1</span>))</span><br><span class="line"><span class="comment">//2.0-1.1 输出的结果精确为0.9</span></span><br></pre></td></tr></table></figure></p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串就是一系列的字符，在java中，字符串可以包含任何Unicode字符。</p><h4 id="字符串连接"><a href="#字符串连接" class="headerlink" title="字符串连接"></a>字符串连接</h4><p>可以使用操作符＋连接两个字符串<br>如果将一个字符串和另一个值连接起来，另一个值会转换为字符串。</p><p>==注意　如果将连接与加写在一起，可能会有意想不到的结果==<br>例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> age =<span class="number">20</span>;</span><br><span class="line"><span class="string">"your age :"</span> + age + <span class="number">1</span>;</span><br><span class="line"><span class="comment">//结果为　your age : 201</span></span><br><span class="line"><span class="comment">//正确为"your age :" + （age + 1）;</span></span><br></pre></td></tr></table></figure></p><p>也可以使用String类下的join方法讲几个字符串连接起来并以分割符隔开<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String names = String.join(<span class="string">","</span>,<span class="string">"Mino"</span>,<span class="string">"Peter"</span>,<span class="string">"Paul"</span>);</span><br><span class="line"><span class="comment">//names的结果为“Mino,Peter,Paul“</span></span><br><span class="line"><span class="comment">//或者第二个参数提供字符串数组</span></span><br></pre></td></tr></table></figure></p><p>如果有大量字符串需要连接，那么上面这种方式是效率低下的，最好使用StringBuilder代替<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">while</span>(isMoreString)&#123;</span><br><span class="line">    builder.append(nextString);</span><br><span class="line">&#125;</span><br><span class="line">String result = builder.toString();</span><br></pre></td></tr></table></figure></p><h4 id="子字符串（字符串拆分）"><a href="#子字符串（字符串拆分）" class="headerlink" title="子字符串（字符串拆分）"></a>子字符串（字符串拆分）</h4><p>可以使用substring方法将字符串拆开<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String greeting = <span class="string">"Hello world"</span>;</span><br><span class="line">String location = greeting.substring(<span class="number">7</span>,<span class="number">12</span>);</span><br><span class="line"><span class="comment">//设置location为"world"(起位置７　结束位置12,字符串的位置从０开始)</span></span><br></pre></td></tr></table></figure></p><p>你也可以用split()方法将含有分隔符分割的字符串提取出子字符串，返回一个子字符串数组。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String names = <span class="string">"Peter,Mino,Mary"</span>;</span><br><span class="line">String[] result = names.split(<span class="string">","</span>);</span><br><span class="line"><span class="comment">//返回的结果值为数组["Peter","Mino","Mary"]</span></span><br></pre></td></tr></table></figure></p><h4 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">location.equals(<span class="string">"world"</span>);</span><br><span class="line"><span class="comment">//若location是字符串”world“,返回真</span></span><br></pre></td></tr></table></figure><p>==不要使用<code>==</code>操作符来比较字符串，只有当两者在内存中为同一对象时，返回真，（可以看成地址的比较）。在Java虚拟机中，每个文字串只有一个实例，所以”world“<code>==</code>“world”为真，但是如果字符串是计算得来的，那么变量中的字符串会单独存放到一个实例中，此时虽然他们的值相等，但<code>==</code>返回值为假==</p><p>例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"world"</span>==<span class="string">"world"</span>;</span><br><span class="line"><span class="comment">//返回true</span></span><br><span class="line">String greeting = <span class="string">"Hello world"</span>;</span><br><span class="line">String location = greeting.substring(<span class="number">7</span>,<span class="number">12</span>);</span><br><span class="line">location == <span class="string">"world"</span>;</span><br><span class="line"><span class="comment">//返回false</span></span><br></pre></td></tr></table></figure></p><p>与其他任何变量一样，String变量可以是null，这表明该变量根本没有引用任何对象，甚至不是一个空字符串。</p><p>null与空字符串<code>&quot;&quot;</code>并不相同。空字符串是个长度为零的字符串，而null根本不是字符串。在null上调用任何方法都会抛出空指针异常。</p><ul><li>可以使用<code>==</code>来测试一个字符串是否为null.<code>if(location == null)...</code></li><li>比较字符串和文字串时，将文字串放在前面会是一个好主意，英文即使字符串为null，这个语句也可以正常工作<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="string">"world"</span>.equals(location)) ...</span><br></pre></td></tr></table></figure></li></ul><h5 id="equalsIgnoreCase方法"><a href="#equalsIgnoreCase方法" class="headerlink" title="equalsIgnoreCase方法"></a>equalsIgnoreCase方法</h5><p>不考虑大小写的比较两个字符串</p><h5 id="compareTo方法"><a href="#compareTo方法" class="headerlink" title="compareTo方法"></a>compareTo方法</h5><p>可以告诉你两个字符串按照字典中的顺序（依赖于Unicode值）哪个在前。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">first.compareTo(second)</span><br></pre></td></tr></table></figure></p><ul><li>返回值&lt;0(负整数)，first排前</li><li>返回值=0 ,两者相等</li><li>返回值&gt;0(正整数),second排前</li></ul><p>对用户可读的字符串排序时，推荐使用Collator对象（它知道关于特定语言的排序规则）。</p><h4 id="数字与字符串转换"><a href="#数字与字符串转换" class="headerlink" title="数字与字符串转换"></a>数字与字符串转换</h4><p><strong>整数转换为字符串</strong>　可调用静态方法　Integer.toString(num);<br>可以传入第二个参数作为转换的进制（2~36）Integer.toString(num , 2); 则返回为num转换为２进制之后的结果</p><ul><li>将整数转换为字符串的更简单的办法是<code>&quot;&quot;+num</code>.但是有些人认为这种方式比较丑陋并且效率低下。</li></ul><p>相反</p><p><strong>将整数的字符串转为数字</strong>，使用Integer.parseInt方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n = Integer.parseInt(<span class="string">"11"</span>);</span><br><span class="line"><span class="comment">//也可以指定进制数</span></span><br><span class="line">m = Integer.parseInt(<span class="string">"11"</span>,<span class="number">2</span>);</span><br><span class="line"><span class="comment">//ｍ的值为整数３</span></span><br></pre></td></tr></table></figure></p><p>对于<strong>浮点数</strong>，也有对应的Double.toString和Double.parseDouble方法。</p><h4 id="String类API"><a href="#String类API" class="headerlink" title="String类API"></a>String类API</h4><p><strong><em>有用的String类方法</em></strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/core_java_post/day3-1.jpg" alt="有用的String类方法" title="">                </div>                <div class="image-caption">有用的String类方法</div>            </figure><br>注意，在Java 中　String 类是不可变的(immutable)．也就是说任何String类的方法都不能修改自己的字符串。返回的是一个新的字符串，源字符串不会改变。</p><p>== 可以在网上下载详细的JavaAPI文档，里面有各个API的详解 ==</p><h4 id="编码点和编码单元"><a href="#编码点和编码单元" class="headerlink" title="编码点和编码单元"></a>编码点和编码单元</h4><p>Java开始创建时，拥抱了刚出来不久的Unicode标准，目的是解决棘手的字符编码的问题在Unicode之前，有很多不兼容的字符编码方式，每个国家都在做类似的事情，拓展ASCII标准来容纳各自的语言符号，不同编码文件之间的交流成为了一个大问题。</p><p>现在，Unicode需要21个bit，而不是设计之初的16bit(因为引入了比实际时估计更多的字符而扩容)。每个有效的Unicode值被称为编码点(code point).</p><p>Java 诞生在16bit向21bit过度的时期，深受其苦。在Java中，字符串不是Unicode字符或者编码点的序列，而是编码单元(code unit),UTF-16编码的１６比特序列.<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/core_java_post/day3-2.jpg" alt="编码点和编码单元的一些方法" title="">                </div>                <div class="image-caption">编码点和编码单元的一些方法</div>            </figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-4-操作运算&quot;&gt;&lt;a href=&quot;#1-4-操作运算&quot; class=&quot;headerlink&quot; title=&quot;1.4 操作运算&quot;&gt;&lt;/a&gt;1.4 操作运算&lt;/h2&gt;&lt;p&gt;Java 与基于Ｃ语言的所有语言使用相似的操作符，接下来我来找一些在java需要注意的地方。
      
    
    </summary>
    
      <category term="学习笔记" scheme="https://minoyu.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java" scheme="https://minoyu.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/"/>
    
    
      <category term="学习笔记" scheme="https://minoyu.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《Java核心技术》" scheme="https://minoyu.github.io/tags/%E3%80%8AJava%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Core Java Day 2--基本编程结构2(基本类型、变量)</title>
    <link href="https://minoyu.github.io/2018/10/19/Core-Java-Day-2-%E5%9F%BA%E6%9C%AC%E7%BC%96%E7%A8%8B%E7%BB%93%E6%9E%84-2/"/>
    <id>https://minoyu.github.io/2018/10/19/Core-Java-Day-2-基本编程结构-2/</id>
    <published>2018-10-19T11:50:07.000Z</published>
    <updated>2019-01-23T12:51:49.727Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-2-基本类型"><a href="#1-2-基本类型" class="headerlink" title="1.2 基本类型"></a>1.2 基本类型</h2><p>接下来我们来看一下Java中7的基本类型。最简单的Java类型被称为基本类型，这些与C/C++基本类似，详细的我就不在这里介绍了，主要找一些需要注意的地方吧</p><h3 id="1-2-1-整型"><a href="#1-2-1-整型" class="headerlink" title="1.2.1 整型"></a>1.2.1 整型</h3><p>整型是没有小数部分的数字，java中有四种整型</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/core_java_post/day2-1.jpg" alt="java中的四种整型" title="">                </div>                <div class="image-caption">java中的四种整型</div>            </figure><ol><li>我们可以通过这些类的<code>.MIN_VALUE</code>,<code>.MAX_VALUE</code>常量获取到其可取到的最大值和最小值</li></ol><p>如果<code>long</code>类型还不够用，则使用<code>BigInteger</code>类</p><ol><li>与C/C++不同的是，Java中的整型范围不依赖程序所运行的机器。”编写一次 到处运行”;</li><li>在java中你还可以给数字添加下划线 ，使阅读变得更加容易，Java编译器会删除他们。例如1_000_000。</li></ol><h3 id="1-2-2-浮点类型"><a href="#1-2-2-浮点类型" class="headerlink" title="1.2.2 浮点类型"></a>1.2.2 浮点类型</h3><p>浮点类型是指有分数的数字<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/core_java_post/day2-2.jpg" alt="浮点类型" title="">                </div>                <div class="image-caption">浮点类型</div>            </figure></p><ol><li>float类有个F后缀（例如 <code>3.14F</code>）。没有F后缀的浮点类型被默认为Double 你可以选择D作为double类型的后缀（例如3.14D）</li><li>有一个特殊的浮点值 <code>Double.POSITIVE_INFINITY</code> 代表正无穷 <code>Double.NEGATIVE_INFINITY</code> 代表负无穷。例如，1.0/0.0结果就是无穷大。<br>3.<code>Double.NaN</code>代表非数值， 0例如，.0/0.0或者负数的平方根就会产生无数值NaN。</li><li>需要注意的是，所有的NaN 都被认为是彼此不同的所以不能用简单的<code>if(x == NaN)</code>来检查x是否是<code>NaN</code>。但是，你可以使用<code>Double.isNaN(x)</code>来判断。同样 你还可以使用Double.isInfinite来测试是否为正负无穷大 用方法<code>Double.isFinite</code>可以检查浮点数既不是无穷也不是NaN</li></ol><p>有时浮点数会存在一些舍入误差，并不适用于对精度要求特别高的地方 例如命令</p><p>System.out.println(2.0-1.1)的打印结果为0.899999999999999… 而非我们所期望的0.9</p><p>这样的原因是浮点数使用了二进制系统进行表示。分数十分之一没法用精确的二进制表示。就好像分时三分之一在十进制下无法精确表示一样。如果你需要精确而无舍入误差的数字计算 你可以使用BigDecimal类</p><h3 id="1-2-3-char-型"><a href="#1-2-3-char-型" class="headerlink" title="1.2.3 char 型"></a>1.2.3 char 型</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/core_java_post/day2-3.jpg" alt="char类型" title="">                </div>                <div class="image-caption">char类型</div>            </figure><p>你可能不会经常使用char型，char型描述了Java使用的UTF-16字符编码中的“编码单元”;</p><h3 id="1-2-4-布尔型"><a href="#1-2-4-布尔型" class="headerlink" title="1.2.4 布尔型"></a>1.2.4 布尔型</h3><p>布尔型有两种值 true 和 false</p><p>但值得注意的是 在java中布尔类型不是数字类型。布尔值与整数0和1没有关系</p><h2 id="1-3-变量"><a href="#1-3-变量" class="headerlink" title="1.3 变量"></a>1.3 变量</h2><p>关于如何声明与初始化变量与常量</p><h3 id="1-3-1变量的声明"><a href="#1-3-1变量的声明" class="headerlink" title="1.3.1变量的声明"></a>1.3.1变量的声明</h3><p>Java是强类型语言。变量值只能是某个具体类型的值。当你声明变量时，需要指定变量的类型、名称和一个可选的初始值。</p><p>如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> total = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p><p>这部分基本与C/C++类似</p><p>&quot;大多数Java程序员喜欢每个变量有各自单独的声明&quot;</p><p>当你声明变量并用构造对象初始化变量时，对象所属类的名称会出现两次：如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Random generator = <span class="keyword">new</span> Random();</span><br><span class="line"><span class="comment">//第一个变量Random 是变量generator的类型。第二个Random是构造该类对象的表达式的一部分。</span></span><br></pre></td></tr></table></figure></p><h3 id="1-3-2-关于变量的名称"><a href="#1-3-2-关于变量的名称" class="headerlink" title="1.3.2 关于变量的名称"></a>1.3.2 关于变量的名称</h3><p>允许的变量名格式与C、C++基本类似</p><p>根据习惯 变量和方法的名称以小写字母开始，类的名称的第一个字母大写。</p><p>Java程序员喜欢使用&quot;驼峰式大小写&quot;，也就是当名称由多个单词组成时，单词首字母大写，例如countOfNums。</p><h3 id="1-3-3-初始化"><a href="#1-3-3-初始化" class="headerlink" title="1.3.3 初始化"></a>1.3.3 初始化</h3><ol><li>和C、C++相同，你必须再使用变量前对声明的变量进行初始化</li><li>允许在方法的任何地方声明变量，但尽可能晚地声明变量，刚好在你首次需要变量的前一刻声明，被认为是一种好习惯。</li></ol><h3 id="1-3-4-常量"><a href="#1-3-4-常量" class="headerlink" title="1.3.4 常量"></a>1.3.4 常量</h3><p>关键词final表示一个值，一旦赋值后就不能改变了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> DAYS_PER_WEEK = <span class="number">7</span>;</span><br></pre></td></tr></table></figure></p><p>根据习惯，常量的名称使用大写字母。</p><p>你也可以在方法外，使用static关键词声明常量。例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calendar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DAYS_PER_WEEK = <span class="number">7</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>常量可以用在多个方法中。在Calendar类内部，你可以直接引用常量DAYS_PER_WEEK。而要在其他的类中使用常量，前面要加上类名：Calendar.DAYS_PER_WEEK。</p><p>例如我们常用的输出对象</p><p>System类中声明了一个out常量<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> PrintStream out;</span><br></pre></td></tr></table></figure></p><p>于是 你就可以在任何地方愉快的使用System.out对象了。貌似这是极少数几个常量没有大写的情况</p><ol><li><p>延迟final变量的初始化是允许的，只要确保它在使用之前恰好初始化了一次即可，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> DAYS_IN_FEBRUARY;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(oleapYear)&#123;</span><br><span class="line">    DAYS_IN_FEBRUARY =<span class="number">29</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    DAYS_IN_FEBRUARY = <span class="number">28</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>final变量 一旦被赋值 它就是最终的值，且无法被改变。</p></li></ol><p>如果你需要定义一组相关的常量，这时你可以定义枚举类型了。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/core_java_post/day2-4.jpg" alt="枚举类型" title="">                </div>                <div class="image-caption">枚举类型</div>            </figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-2-基本类型&quot;&gt;&lt;a href=&quot;#1-2-基本类型&quot; class=&quot;headerlink&quot; title=&quot;1.2 基本类型&quot;&gt;&lt;/a&gt;1.2 基本类型&lt;/h2&gt;&lt;p&gt;接下来我们来看一下Java中7的基本类型。最简单的Java类型被称为基本类型，这些与C/C+
      
    
    </summary>
    
      <category term="学习笔记" scheme="https://minoyu.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java" scheme="https://minoyu.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/"/>
    
    
      <category term="学习笔记" scheme="https://minoyu.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《Java核心技术》" scheme="https://minoyu.github.io/tags/%E3%80%8AJava%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Core Java Day 1--基本编程结构1(Hello World)</title>
    <link href="https://minoyu.github.io/2018/10/19/Core-Java-Day-1-%E5%9F%BA%E6%9C%AC%E7%BC%96%E7%A8%8B%E7%BB%93%E6%9E%84-1/"/>
    <id>https://minoyu.github.io/2018/10/19/Core-Java-Day-1-基本编程结构-1/</id>
    <published>2018-10-19T09:02:06.000Z</published>
    <updated>2019-01-23T12:51:49.726Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于这个笔记"><a href="#关于这个笔记" class="headerlink" title="关于这个笔记"></a>关于这个笔记</h2><p>最近开始想系统性的啃一啃Java，觉得以前自己学的都太乱太杂，反而学艺不精。现在准备开始照着《Java核心技术》开始怼下去，希望自己可以坚持下去吧，这次不弃坑不弃坑 T.T</p><h1 id="1-基本编程结构"><a href="#1-基本编程结构" class="headerlink" title="1.基本编程结构"></a>1.基本编程结构</h1><h2 id="一些要点"><a href="#一些要点" class="headerlink" title="一些要点"></a>一些要点</h2><ol><li>Java中所有的方法必须在类中声明。非静态方法只能在该方法所属类的对象上调用</li><li>静态方法不是通过对象调用。程序从静态的main方法开始执行</li><li>Java有8个基本数据类型： 5个整型 2个浮点型和1个布尔型</li><li>Java操作符和控制结构与C/Javascript非常相似</li><li>Math类提供常见的数学函数</li><li>字符串对象是字符序列，或者更精确的说 是UTF-16编码中Unicode编码点的序列</li><li>Java中使用System.out对象 可在终端窗口显示输出 绑定System.in的Scanner可以读取终端输入</li><li>数组和集合用来收集相同类型的元素</li></ol><h2 id="1-1-Hello-World"><a href="#1-1-Hello-World" class="headerlink" title="1.1 Hello World"></a>1.1 Hello World</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/core_java_post/day1-1.jpg" alt="一个简单的Hello World程序" title="">                </div>                <div class="image-caption">一个简单的Hello World程序</div>            </figure><p><strong>一些解析</strong></p><ol><li>Java是面向对象的一门语言，绝大多数情况下通过操作_对象_来进行工作。对象属于某个类，类定义了对象能做什么。在Java中，所有的代码都必须在类中定义好。例如在这个HelloWorld程序由一个HelloWorld类组成。</li><li>main是方法，也就是在类中声明的函数。main方法是程序运行时调用的第一个方法。它被声明为静态static，表示该方法不是依赖于对象运行的。方法声明为void，指出该方法不会有返回值。</li><li>在Java中可以声明一些特性（可见性） 例如public或private</li><li>package（包） 是一组相关类的集合。每个类都放入一个包中，这样就可以区分相同类名的多个类。</li><li>回到main方法的方法体中 它由一行语句组成，作用是讲消息打印到讲讲System.out对象 该对象在Java中代表标准输出</li></ol><p>所以，Java被明确定义为可以从组织有序的类和包中获益的大型程序的编程语言</p><p>在Java中 所有的一切都必须在类中声明相当简单和一致</p><h3 id="1-1-2-Java程序的编译与运行"><a href="#1-1-2-Java程序的编译与运行" class="headerlink" title="1.1.2 Java程序的编译与运行"></a>1.1.2 Java程序的编译与运行</h3><p>安装好JDK之后，我们可以运行用终端打开，输入以下的命令，以刚才的Hello World为例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ javac ch01/sec01/HelloWorld.java</span><br><span class="line">//javac命令将java源代码编译为中间代码，也称为字节码，并将他们保存到类文件中。</span><br><span class="line"></span><br><span class="line">$ java ch01.sec01.HelloWorld</span><br><span class="line">//Java 命令启动虚拟机，虚拟机加载类文件并执行字节码。</span><br></pre></td></tr></table></figure><p>所以，一旦编译完成，字节码可以在任何Java虚拟机上运行 &quot; 编写一次，到处运行 &quot;</p><h3 id="1-1-3-方法调用"><a href="#1-1-3-方法调用" class="headerlink" title="1.1.3 方法调用"></a>1.1.3 方法调用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"Hello World!"</span>);</span><br></pre></td></tr></table></figure><p>System.out是对象。这是PrintStream类的实例。PrintStream类有println、print等方法。</p><p>类似这样的方法被称为实例方法，他们运行在对象，或者类的实例上。</p><p>调用对象上的实例方法使用点符号<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object.methodName(arguments)</span><br></pre></td></tr></table></figure></p><p>另一个例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"Hello world"</span>.length();</span><br></pre></td></tr></table></figure></p><p>此处的 “Hello world” 是String类的实例，String 有一个length方法 用于返回字符串对象的长度。</p><p>在Java中 你需要构造绝大多数的对象（而不是像此处的System.out和”Hello World”对象直接使用就好，因为他们已经存在）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 类名 ( 构造函数的参数列表 );</span><br></pre></td></tr></table></figure><p>举个例子Random类的对象可以产生随机数，你可以使用new操作符构建一个Random对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Random();</span><br></pre></td></tr></table></figure></p><p>此处的构造函数参数为空</p><p>你可以直接在构造对象上调用方法，例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Random().nextInt();</span><br></pre></td></tr></table></figure><p>新构造的随机数产生器会提供一个整数</p><p>如果想要在一个对象上调用多个方法，可以先将该对象用变量存下来，例如接下来我们打印两个随机数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Random generator = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">System.out.println(generator.nextInt());</span><br><span class="line"></span><br><span class="line">System.out.println(generator.nextInt());</span><br></pre></td></tr></table></figure><p>注意 Random类声明在java.util包中。要在程序中使用该类，需要添加import声明，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;关于这个笔记&quot;&gt;&lt;a href=&quot;#关于这个笔记&quot; class=&quot;headerlink&quot; title=&quot;关于这个笔记&quot;&gt;&lt;/a&gt;关于这个笔记&lt;/h2&gt;&lt;p&gt;最近开始想系统性的啃一啃Java，觉得以前自己学的都太乱太杂，反而学艺不精。现在准备开始照着《Java核心技
      
    
    </summary>
    
      <category term="学习笔记" scheme="https://minoyu.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java" scheme="https://minoyu.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/"/>
    
    
      <category term="学习笔记" scheme="https://minoyu.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《Java核心技术》" scheme="https://minoyu.github.io/tags/%E3%80%8AJava%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Hello World! My first hexo post! (hexo的常用命令及优化)</title>
    <link href="https://minoyu.github.io/2018/10/18/hello-world/"/>
    <id>https://minoyu.github.io/2018/10/18/hello-world/</id>
    <published>2018-10-18T09:02:06.000Z</published>
    <updated>2019-01-24T13:04:09.538Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于这里"><a href="#关于这里" class="headerlink" title="关于这里"></a>关于这里</h1><p>哈哈哈，第一次尝试用Hexo来搭建一个博客，放在github page上，尝试了一下。<strong>以后这里主要用来记录我的学习笔记和一些探索总结吧</strong>。</p><p>话说觉得Hexo真的好神奇，脱离了数据库，用一个个md文档充当文章的内容，在本地写好md文档后编译成Html,再推上服务器。实现了纯静态的访问，蛮有意思的XD</p><h3 id="那就这样吧，接下来开始我的记录咯。"><a href="#那就这样吧，接下来开始我的记录咯。" class="headerlink" title="那就这样吧，接下来开始我的记录咯。"></a>那就这样吧，接下来开始我的记录咯。</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My First Note！"</span></span><br></pre></td></tr></table></figure><p>个人博客: <a href="https://we.sharelove.site/" target="_blank" rel="noopener">我们的小确幸</a></p><h1 id="hexo的常用命令"><a href="#hexo的常用命令" class="headerlink" title="hexo的常用命令"></a>hexo的常用命令</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新建文章</span></span><br><span class="line">$ hexo new [layout] &lt;title&gt;</span><br><span class="line"><span class="comment"># 生成静态文件</span></span><br><span class="line">$ hexo g</span><br><span class="line"><span class="comment"># 部署网站</span></span><br><span class="line">$ hexo d</span><br><span class="line"><span class="comment"># 清除缓存文件 (db.json) 和已生成的静态文件 (public)。</span></span><br><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure><h1 id="hexo的优化"><a href="#hexo的优化" class="headerlink" title="hexo的优化"></a>hexo的优化</h1><p>虽然hexo已经很优秀了，但考虑到毕竟是放在github page上的，还是稍微做一些优化。</p><h2 id="静态资源优化"><a href="#静态资源优化" class="headerlink" title="静态资源优化"></a>静态资源优化</h2><p>主要是压缩html,css,js等等静态资源，可以适当减少请求的数据量，主要用到gulp来实现。</p><ol><li>安装gulp</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全局安装gulp工具 以yarn工具为例</span></span><br><span class="line">$ yarn global add gulp-cli</span><br><span class="line"><span class="comment"># 给项目安装各种gulp插件 分别负责压缩html 图片 css js</span></span><br><span class="line">$ yarn add gulp gulp-htmlclean gulp-htmlmin gulp-imagemin gulp-minify-css gulp-uglify</span><br></pre></td></tr></table></figure><ol start="2"><li>配置文件</li></ol><p>在根目录下添加<code>gulpfile.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">var</span> minifycss = <span class="built_in">require</span>(<span class="string">'gulp-minify-css'</span>);</span><br><span class="line"><span class="keyword">var</span> uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>);</span><br><span class="line"><span class="keyword">var</span> htmlmin = <span class="built_in">require</span>(<span class="string">'gulp-htmlmin'</span>);</span><br><span class="line"><span class="keyword">var</span> htmlclean = <span class="built_in">require</span>(<span class="string">'gulp-htmlclean'</span>);</span><br><span class="line"><span class="keyword">var</span> imagemin = <span class="built_in">require</span>(<span class="string">'gulp-imagemin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩html</span></span><br><span class="line">gulp.task(<span class="string">'minify-html'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">'./public/**/*.html'</span>)</span><br><span class="line">        .pipe(htmlclean())</span><br><span class="line">        .pipe(htmlmin(&#123;</span><br><span class="line">            removeComments: <span class="literal">true</span>,</span><br><span class="line">            minifyJS: <span class="literal">true</span>,</span><br><span class="line">            minifyCSS: <span class="literal">true</span>,</span><br><span class="line">            minifyURLs: <span class="literal">true</span>,</span><br><span class="line">        &#125;))</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'./public'</span>))</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 压缩css</span></span><br><span class="line">gulp.task(<span class="string">'minify-css'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">'./public/**/*.css'</span>)</span><br><span class="line">        .pipe(minifycss(&#123;</span><br><span class="line">            compatibility: <span class="string">'ie8'</span></span><br><span class="line">        &#125;))</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'./public'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 压缩js</span></span><br><span class="line">gulp.task(<span class="string">'minify-js'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">'./public/js/**/*.js'</span>)</span><br><span class="line">        .pipe(uglify())</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'./public'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 压缩图片</span></span><br><span class="line">gulp.task(<span class="string">'minify-images'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">'./public/img/**/*.*'</span>)</span><br><span class="line">        .pipe(imagemin(</span><br><span class="line">        [imagemin.gifsicle(&#123;<span class="string">'optimizationLevel'</span>: <span class="number">3</span>&#125;), </span><br><span class="line">        imagemin.jpegtran(&#123;<span class="string">'progressive'</span>: <span class="literal">true</span>&#125;), </span><br><span class="line">        imagemin.optipng(&#123;<span class="string">'optimizationLevel'</span>: <span class="number">7</span>&#125;), </span><br><span class="line">        imagemin.svgo()],</span><br><span class="line">        &#123;<span class="string">'verbose'</span>: <span class="literal">true</span>&#125;))</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'./public/img'</span>))</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.0以前的写法 </span></span><br><span class="line"><span class="comment">//gulp.task('default', [</span></span><br><span class="line">  <span class="comment">//  'minify-html', 'minify-css', 'minify-js'，'minify-images'</span></span><br><span class="line"><span class="comment">//]);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认任务 gulp4以上写法 gulp.parallel 任务同时进行</span></span><br><span class="line">gulp.task(<span class="string">'default'</span>, gulp.parallel(</span><br><span class="line">    <span class="string">'minify-html'</span>,</span><br><span class="line">    <span class="string">'minify-css'</span>,</span><br><span class="line">    <span class="string">'minify-js'</span>,</span><br><span class="line">    <span class="string">'minify-images'</span></span><br><span class="line">));</span><br></pre></td></tr></table></figure><ol start="3"><li>在hexo g生成文件后运行gulp<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g</span><br><span class="line">$ gulp</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure></li></ol><h2 id="生成sitemap文件"><a href="#生成sitemap文件" class="headerlink" title="生成sitemap文件"></a>生成sitemap文件</h2><p>生成sitemap文件然后提交给搜索引擎，对于SEO很有帮助，hexo有相关的sitemap插件。</p><p>安装这俩插件后，以后每次hexo g都会生成sitemap.xml和baidusitemap.xml文件并自动帮你放到public目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn add hexo-generator-sitemap hexo-generator-baidu-sitemap</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;关于这里&quot;&gt;&lt;a href=&quot;#关于这里&quot; class=&quot;headerlink&quot; title=&quot;关于这里&quot;&gt;&lt;/a&gt;关于这里&lt;/h1&gt;&lt;p&gt;哈哈哈，第一次尝试用Hexo来搭建一个博客，放在github page上，尝试了一下。&lt;strong&gt;以后这里主要用来记录我
      
    
    </summary>
    
      <category term="奇怪的东西" scheme="https://minoyu.github.io/categories/%E5%A5%87%E6%80%AA%E7%9A%84%E4%B8%9C%E8%A5%BF/"/>
    
    
      <category term="杂类" scheme="https://minoyu.github.io/tags/%E6%9D%82%E7%B1%BB/"/>
    
      <category term="Hello world" scheme="https://minoyu.github.io/tags/Hello-world/"/>
    
  </entry>
  
</feed>
